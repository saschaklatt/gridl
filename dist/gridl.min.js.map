{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gridl.min.js","webpack:///webpack/bootstrap 8490715a6c1273bfa691","webpack:///./src/utils.js","webpack:///./src/index.js","webpack:///./src/directions.js","webpack:///./src/generators.js","webpack:///./src/plugins/index.js","webpack:///./src/plugins/adjacence.js","webpack:///./src/plugins/area.js","webpack:///./src/plugins/clipping.js","webpack:///./src/plugins/columns.js","webpack:///./src/plugins/finding.js","webpack:///./src/plugins/flipping.js","webpack:///./src/plugins/iterator.js","webpack:///./src/plugins/moving.js","webpack:///./src/plugins/rotating.js","webpack:///./src/plugins/rows.js","webpack:///./src/plugins/state.js","webpack:///./src/plugins/swapping.js","webpack:///./src/plugins/value.js","webpack:///./src/adjacences.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","value","index2pos","index","columns","Math","floor","pos2index","position","countRows","array2D","countColumns","flatten","reduce","res","row","concat","unflatten","array1D","rows","r","pos","addPositions","p1","p2","subtractPositions","limit","min","max","isNotInArea","areaSize","getValueAt","data","isNaN","setValueAt","getColumn","x","map","isValidPositionFormat","Number","isSafeInteger","validateGridArray","Error","forEach","utils","default","_interopRequireDefault","obj","registerPlugins","state","_this","register","_ref","_ref2","_slicedToArray","key","pluginFactory","plugin","type","_typeof","methods","namespace","entries","_ref3","_ref4","k","func","usedPlugins","gridl","initialState","directions","adjacences","generators","undefined","Symbol","iterator","constructor","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","push","err","TypeError","_utils","_utils2","_generators","_generators2","_plugins","_plugins2","_directions","_directions2","_adjacences","_adjacences2","gridlFactory","use","id","_ref5","_ref6","freeze","UP","UP_RIGHT","RIGHT","DOWN_RIGHT","DOWN","DOWN_LEFT","LEFT","UP_LEFT","makeDataGrid","callback","arguments","parsedColumns","parseInt","parsedRows","vr","vc","column","makeDataList","parsedLength","v","makeGridl","numColumns","numRows","_index2","_index","_adjacence","_adjacence2","_area","_area2","_clipping","_clipping2","_columns","_columns2","_finding","_finding2","_flipping","_flipping2","_iterator","_iterator2","_moving","_moving2","_rotating","_rotating2","_rows","_rows2","_state","_state2","_swapping","_swapping2","_value","_value2","adjacence","area","clipping","finding","flip","moving","rotating","swapping","context","adjacentCellsAt","ALL","includeOutsideValues","gridSize","grid","_adjacentCells","direction","absPos","instance","areaDescription","_validateAreaDescription","_areaDescription2","_areaDescription2$","_areaDescription2$2","_areaDescription2$3","_x","_areaDescription2$4","_y","_areaDescription2$5","_ax","_areaDescription2$6","_ay","_position","_anchor","_size","_getAreaAt","size","subgrid","api","anchor","localToGlobal","localPosition","valueAt","_newColumns","apply","_setAreaAt","parent","initialValue","reducer","acc","local","thisArg","mapper","newData","fill","callbackOrValue","find","description","isInside","otherAreaDescription","_contains","contains","intersectsWith","_overlap","posTmp","end","rArea","cArea","targetPos","cell","_validateAreaMember","member","_areaDescription","_areaDescription$","_areaDescription$2","_areaDescription$3","_areaDescription$4","_areaDescription$5","_areaDescription$6","_areaStartAndEnd","areaDesc","start","innerAreaDesc","outerAreaDesc","inner","outer","areaDesc1","areaDesc2","area1","area2","clipAt","_clip","endPoint","filter","addColumn","splice","removeColumn","findIndex","flipY","yPos","_flip","flipX","xPos","reverse","limitedIdx","left","moveCell","to","_moveCell","moveColumn","xFrom","xTo","_move","moveRow","yFrom","yTo","fromIndex","toIndex","_rotate","steps","mod","rotate","y","getRow","addRow","removeRow","list","clone","swapCells","position1","position2","_swapCells","swapColumns","x1","x2","_swap","swapRows","y1","y2","i1","i2","tmp","index1","index2","ALL_CW","ALL_CCW","ORTHOGONAL","ORTHOGONAL_CW","ORTHOGONAL_CCW","DIAGONAL","DIAGONAL_CW","DIAGONAL_CCW"],"mappings":"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","file":"gridl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nvar index2pos = exports.index2pos = function index2pos(index, columns) {\n    return [index % columns, Math.floor(index / columns)];\n};\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nvar pos2index = exports.pos2index = function pos2index(position, columns) {\n    return position && position[0] + position[1] * columns;\n};\n\n/**\n * Count the number of rows in a two-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<any>>} array2D - The input array.\n * @returns {number} The number of rows.\n */\nvar countRows = exports.countRows = function countRows(array2D) {\n    return array2D.length || 0;\n};\n\n/**\n * Count the number of columns in a two-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<any>>} array2D - The input array.\n * @returns {number} The number of columns.\n */\nvar countColumns = exports.countColumns = function countColumns(array2D) {\n    return array2D && array2D[0] && array2D[0].length || 0;\n};\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nvar flatten = exports.flatten = function flatten(array2D) {\n    return array2D.reduce(function (res, row) {\n        return [].concat(_toConsumableArray(res), _toConsumableArray(row));\n    }, []);\n};\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @param {number} rows - The number of rows the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nvar unflatten = exports.unflatten = function unflatten(array1D, columns, rows) {\n    var res = [];\n    for (var r = 0; r < rows; r++) {\n        res[r] = [];\n        for (var c = 0; c < columns; c++) {\n            var pos = [c, r];\n            var i = pos2index(pos, columns);\n            res[r][c] = array1D[i];\n        }\n    }\n    return res;\n};\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nvar addPositions = exports.addPositions = function addPositions(p1, p2) {\n    return [p1[0] + p2[0], p1[1] + p2[1]];\n};\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nvar subtractPositions = exports.subtractPositions = function subtractPositions(p1, p2) {\n    return [p1[0] - p2[0], p1[1] - p2[1]];\n};\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nvar limit = exports.limit = function limit(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n};\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nvar isNotInArea = exports.isNotInArea = function isNotInArea(areaSize, position) {\n    return position[0] < 0 || position[0] >= areaSize[0] || position[1] < 0 || position[1] >= areaSize[1];\n};\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nvar getValueAt = exports.getValueAt = function getValueAt(data, columns, pos) {\n    var index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nvar setValueAt = exports.setValueAt = function setValueAt(data, columns, rows, pos, value) {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    var index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nvar getColumn = exports.getColumn = function getColumn(data, x) {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(function (row) {\n            return row[x];\n        });\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nvar isValidPositionFormat = exports.isValidPositionFormat = function isValidPositionFormat(position) {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]);\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nvar validateGridArray = exports.validateGridArray = function validateGridArray(data) {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach(function (row, i) {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with inconsistent number of columns.');\n        }\n        // if (row.length < 1) {\n        //     throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        // }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nvar utils = {\n    countColumns: countColumns,\n    countRows: countRows,\n    flatten: flatten,\n    isValidPositionFormat: isValidPositionFormat,\n    unflatten: unflatten,\n    index2pos: index2pos,\n    pos2index: pos2index,\n    addPositions: addPositions,\n    subtractPositions: subtractPositions,\n    limit: limit,\n    isNotInArea: isNotInArea,\n    getColumn: getColumn,\n    getValueAt: getValueAt,\n    setValueAt: setValueAt,\n    validateGridArray: validateGridArray\n};\n\nexports.default = utils;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.directions = exports.adjacences = exports.generators = exports.utils = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _generators = __webpack_require__(3);\n\nvar _generators2 = _interopRequireDefault(_generators);\n\nvar _plugins = __webpack_require__(4);\n\nvar _plugins2 = _interopRequireDefault(_plugins);\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nvar _adjacences = __webpack_require__(18);\n\nvar _adjacences2 = _interopRequireDefault(_adjacences);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar flatten = _utils2.default.flatten,\n    validateGridArray = _utils2.default.validateGridArray,\n    countColumns = _utils2.default.countColumns,\n    countRows = _utils2.default.countRows;\n\n\nvar usedPlugins = [];\n\nfunction registerPlugins(state) {\n    var _this = this;\n\n    var register = function register(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            pluginFactory = _ref2[1];\n\n        var plugin = pluginFactory(_this, state);\n        var type = typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin);\n\n        // plugin is just a function\n        if (type === 'function') {\n            _this[key] = plugin;\n        }\n\n        // plugin returns multiple functions with a namespace\n        else if (type === 'object' && plugin.methods && plugin.namespace) {\n                _this[key] = plugin.methods;\n            }\n\n            // plugin returns multiple functions without a namespace\n            else if (type === 'object' && plugin.methods) {\n                    Object.entries(plugin.methods).forEach(function (_ref3) {\n                        var _ref4 = _slicedToArray(_ref3, 2),\n                            k = _ref4[0],\n                            func = _ref4[1];\n\n                        _this[k] = func;\n                    });\n                }\n    };\n\n    // Object.entries(plugins).forEach(register);\n    usedPlugins.forEach(register);\n}\n\n/**\n * @class\n * @private\n */\nfunction gridl(data) {\n\n    // validate incoming data\n    validateGridArray(data); // TODO: support no rows and columns, default to to [[]]\n\n    // create initial state\n    var initialState = {\n        rows: countRows(data),\n        columns: countColumns(data),\n        data: flatten(data) // TODO: if no data is provided default to [[]]\n    };\n\n    // register plugins with initial state\n    registerPlugins.call(this, initialState);\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same number of columns.\n */\nvar gridlFactory = function gridlFactory(data) {\n    return new gridl(data);\n};\n\n/**\n * Register a plugin.\n *\n * @param {string} id - An unique ID to identify the plugin.\n * @param {Object} plugin - The plugin itself.\n */\ngridlFactory.use = function (id, plugin) {\n    usedPlugins.push([id, plugin]);\n};\n\n// register core plugins\nObject.entries(_plugins2.default).forEach(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        key = _ref6[0],\n        plugin = _ref6[1];\n\n    return gridlFactory.use(key, plugin);\n});\n\nexports.utils = _utils2.default;\nexports.generators = _generators2.default;\nexports.adjacences = _adjacences2.default;\nexports.directions = _directions2.default;\nexports.default = gridlFactory;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nvar directions = Object.freeze({\n  UP: Object.freeze([0, -1]),\n  UP_RIGHT: Object.freeze([1, -1]),\n  RIGHT: Object.freeze([1, 0]),\n  DOWN_RIGHT: Object.freeze([1, 1]),\n  DOWN: Object.freeze([0, 1]),\n  DOWN_LEFT: Object.freeze([-1, 1]),\n  LEFT: Object.freeze([-1, 0]),\n  UP_LEFT: Object.freeze([-1, -1])\n});\n\nexports.default = directions;\nmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.makeDataGrid = makeDataGrid;\nexports.makeDataList = makeDataList;\nexports.makeGridl = makeGridl;\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nfunction makeDataGrid(columns, rows) {\n    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n        return null;\n    };\n\n    var parsedColumns = parseInt(columns);\n    var parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error('You need to specify at least one column. Given: ' + columns);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error('You need to specify at least one row. Given: ' + rows);\n    }\n    return Array.from({ length: parsedRows }, function (vr, row) {\n        return Array.from({ length: parsedColumns }, function (vc, column) {\n            return callback({ column: column, row: row });\n        });\n    });\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nfunction makeDataList(length) {\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return null;\n    };\n\n    var parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error('Trying to make a list with an invalid length. Given: ' + length);\n    }\n    return Array.from({ length: parsedLength }, function (v, i) {\n        return callback(i);\n    });\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nfunction makeGridl(numColumns, numRows, callback) {\n    return (0, _index2.default)(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexports.default = {\n    makeGridl: makeGridl,\n    makeDataGrid: makeDataGrid,\n    makeDataList: makeDataList\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _adjacence = __webpack_require__(5);\n\nvar _adjacence2 = _interopRequireDefault(_adjacence);\n\nvar _area = __webpack_require__(6);\n\nvar _area2 = _interopRequireDefault(_area);\n\nvar _clipping = __webpack_require__(7);\n\nvar _clipping2 = _interopRequireDefault(_clipping);\n\nvar _columns = __webpack_require__(8);\n\nvar _columns2 = _interopRequireDefault(_columns);\n\nvar _finding = __webpack_require__(9);\n\nvar _finding2 = _interopRequireDefault(_finding);\n\nvar _flipping = __webpack_require__(10);\n\nvar _flipping2 = _interopRequireDefault(_flipping);\n\nvar _iterator = __webpack_require__(11);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _moving = __webpack_require__(12);\n\nvar _moving2 = _interopRequireDefault(_moving);\n\nvar _rotating = __webpack_require__(13);\n\nvar _rotating2 = _interopRequireDefault(_rotating);\n\nvar _rows = __webpack_require__(14);\n\nvar _rows2 = _interopRequireDefault(_rows);\n\nvar _state = __webpack_require__(15);\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _swapping = __webpack_require__(16);\n\nvar _swapping2 = _interopRequireDefault(_swapping);\n\nvar _value = __webpack_require__(17);\n\nvar _value2 = _interopRequireDefault(_value);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    adjacence: _adjacence2.default,\n    area: _area2.default,\n    clipping: _clipping2.default,\n    columns: _columns2.default,\n    finding: _finding2.default,\n    flip: _flipping2.default,\n    iterator: _iterator2.default,\n    moving: _moving2.default,\n    rotating: _rotating2.default,\n    rows: _rows2.default,\n    state: _state2.default,\n    swapping: _swapping2.default,\n    value: _value2.default\n};\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCellsAt(position) {\n        var adjacence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _index.adjacences.ALL;\n        var includeOutsideValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var gridSize = !includeOutsideValues && [columns, rows];\n        var grid = (0, _utils.unflatten)(data, columns, rows);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        methods: {\n            adjacentCellsAt: adjacentCellsAt\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _adjacentCells = function _adjacentCells(grid, position, adjacence) {\n    var gridSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    return adjacence.reduce(function (res, direction) {\n        var absPos = (0, _utils.addPositions)(position, direction);\n        var value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return (0, _utils.isNotInArea)(gridSize, absPos) ? res : [].concat(_toConsumableArray(res), [value]);\n        } else {\n            return [].concat(_toConsumableArray(res), [value]);\n        }\n    }, []);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = function (instance, state) {\n\n    var area = function area(areaDescription) {\n        _validateAreaDescription(areaDescription);\n\n        // input values\n\n        var _areaDescription2 = _slicedToArray(areaDescription, 6),\n            _areaDescription2$ = _areaDescription2[0],\n            _columns = _areaDescription2$ === undefined ? 0 : _areaDescription2$,\n            _areaDescription2$2 = _areaDescription2[1],\n            _rows = _areaDescription2$2 === undefined ? 0 : _areaDescription2$2,\n            _areaDescription2$3 = _areaDescription2[2],\n            _x = _areaDescription2$3 === undefined ? 0 : _areaDescription2$3,\n            _areaDescription2$4 = _areaDescription2[3],\n            _y = _areaDescription2$4 === undefined ? 0 : _areaDescription2$4,\n            _areaDescription2$5 = _areaDescription2[4],\n            _ax = _areaDescription2$5 === undefined ? 0 : _areaDescription2$5,\n            _areaDescription2$6 = _areaDescription2[5],\n            _ay = _areaDescription2$6 === undefined ? 0 : _areaDescription2$6;\n\n        var _position = [_x, _y];\n        var _anchor = [_ax, _ay];\n        var _size = [_columns, _rows];\n\n        // calculated values\n        var data = _getAreaAt(state.data, state.columns, state.rows, _position, _size, _anchor);\n        var columns = (0, _utils.countColumns)(data);\n        var rows = (0, _utils.countRows)(data);\n        var _size2 = [columns, rows];\n\n        // area api\n        var subgrid = (0, _index2.default)(data);\n        var api = {\n            numRows: function numRows() {\n                return rows;\n            },\n            numColumns: function numColumns() {\n                return columns;\n            },\n            size: function size() {\n                return _size2;\n            },\n            position: function position() {\n                return _position;\n            },\n            anchor: function anchor() {\n                return _anchor;\n            },\n            localToGlobal: function localToGlobal(localPosition) {\n                return (0, _utils.addPositions)(api.position(), localPosition);\n            },\n            valueAt: function valueAt(localPosition, value) {\n                return arguments.length > 1 ? subgrid.valueAt(localPosition, value) : subgrid.valueAt(localPosition);\n            },\n            data: function data(value) {\n                if (arguments.length > 0) {\n                    var _newColumns = (0, _utils.countColumns)(value);\n                    var _newRows = (0, _utils.countRows)(value);\n                    if (_newRows !== rows || _newColumns !== columns) {\n                        throw new Error('New area data has an invalid size.');\n                    }\n                    subgrid.data(value);\n                    return api;\n                }\n                return subgrid.data();\n            },\n            apply: function apply() {\n                _setAreaAt(state.data, state.columns, state.rows, _position, subgrid.data(), _anchor);\n                return instance;\n            },\n            parent: function parent() {\n                return instance;\n            },\n            reduce: function reduce(callback, initialValue) {\n                var reducer = function reducer(acc, v, i) {\n                    var local = (0, _utils.index2pos)(i, columns);\n                    return callback(acc, v, local, api);\n                };\n                return arguments.length < 1 ? (0, _utils.flatten)(data).reduce(reducer) : (0, _utils.flatten)(data).reduce(reducer, initialValue);\n            },\n            map: function map(callback, thisArg) {\n                var mapper = function mapper(v, i) {\n                    var local = (0, _utils.index2pos)(i, columns);\n                    return callback.call(thisArg, v, local, api);\n                };\n                // TODO: looks too complicated (flatten -> unflatten)\n                var newData = (0, _utils.flatten)(data).map(mapper, thisArg);\n                // return a copy with the new data\n                return area(areaDescription).data((0, _utils.unflatten)(newData, columns, rows));\n            },\n            fill: function fill(callbackOrValue, thisArg) {\n                if (typeof callbackOrValue === 'function') {\n                    subgrid.fill(function (v, pos) {\n                        return callbackOrValue.call(thisArg, v, pos, api);\n                    });\n                } else {\n                    subgrid.fill(callbackOrValue);\n                }\n                return api;\n            },\n            find: function find(callbackOrValue, thisArg) {\n                if (typeof callbackOrValue === 'function') {\n                    return subgrid.find(function (v, pos) {\n                        return callbackOrValue.call(thisArg, v, pos, api);\n                    });\n                }\n                return subgrid.find(function (v) {\n                    return v === callbackOrValue;\n                });\n            },\n            forEach: function forEach(callback, thisArg) {\n                var iterator = function iterator(v, i) {\n                    var local = (0, _utils.index2pos)(i, columns);\n                    return callback.call(thisArg, v, local, api);\n                };\n                (0, _utils.flatten)(data).forEach(iterator, thisArg);\n                return api;\n            },\n            description: function description() {\n                return [columns, rows, _x, _y, _ax, _ay];\n            },\n            isInside: function isInside(otherAreaDescription) {\n                _validateAreaDescription(otherAreaDescription);\n                return _contains(api.description(), otherAreaDescription);\n            },\n            contains: function contains(otherAreaDescription) {\n                _validateAreaDescription(otherAreaDescription);\n                return _contains(otherAreaDescription, api.description());\n            },\n            intersectsWith: function intersectsWith(otherAreaDescription) {\n                _validateAreaDescription(otherAreaDescription);\n                return _overlap(api.description(), otherAreaDescription);\n            }\n        };\n        return api;\n    };\n\n    return {\n        methods: { area: area }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _getAreaAt = function _getAreaAt(data, columns, rows, position, size) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var posTmp = (0, _utils.subtractPositions)(position, anchor);\n    var end = [Math.min(posTmp[0] + size[0], columns), Math.min(posTmp[1] + size[1], rows)];\n    var pos = [Math.max(0, posTmp[0]), Math.max(0, posTmp[1])];\n    var area = [];\n    for (var r = pos[1]; r < end[1]; r++) {\n        var rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (var c = pos[0]; c < end[0]; c++) {\n            var cArea = c - pos[0];\n            area[rArea][cArea] = (0, _utils.getValueAt)(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nvar _setAreaAt = function _setAreaAt(data, columns, rows, position, area) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var pos = (0, _utils.subtractPositions)(position, anchor);\n    area.forEach(function (row, r) {\n        var targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach(function (cell, c) {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            (0, _utils.setValueAt)(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nvar _validateAreaMember = function _validateAreaMember(member) {\n    return member === undefined || typeof member === 'number';\n};\n\nvar _validateAreaDescription = function _validateAreaDescription(areaDescription) {\n    if (areaDescription.length > 6) {\n        throw new Error('Invalid area description: too many fields');\n    }\n\n    var _areaDescription = _slicedToArray(areaDescription, 6),\n        _areaDescription$ = _areaDescription[0],\n        _columns = _areaDescription$ === undefined ? 0 : _areaDescription$,\n        _areaDescription$2 = _areaDescription[1],\n        _rows = _areaDescription$2 === undefined ? 0 : _areaDescription$2,\n        _areaDescription$3 = _areaDescription[2],\n        _x = _areaDescription$3 === undefined ? 0 : _areaDescription$3,\n        _areaDescription$4 = _areaDescription[3],\n        _y = _areaDescription$4 === undefined ? 0 : _areaDescription$4,\n        _areaDescription$5 = _areaDescription[4],\n        _ax = _areaDescription$5 === undefined ? 0 : _areaDescription$5,\n        _areaDescription$6 = _areaDescription[5],\n        _ay = _areaDescription$6 === undefined ? 0 : _areaDescription$6;\n\n    if (!_validateAreaMember(_columns)) {\n        throw new Error('Invalid area description: column is not a number');\n    }\n    if (!_validateAreaMember(_rows)) {\n        throw new Error('Invalid area description: row is not a number');\n    }\n    if (!_validateAreaMember(_x)) {\n        throw new Error('Invalid area description: x is not a number');\n    }\n    if (!_validateAreaMember(_y)) {\n        throw new Error('Invalid area description: y is not a number');\n    }\n    if (!_validateAreaMember(_ax)) {\n        throw new Error('Invalid area description: anchorX is not a number');\n    }\n    if (!_validateAreaMember(_ay)) {\n        throw new Error('Invalid area description: anchorY is not a number');\n    }\n    if (_columns && _columns < 0) {\n        throw new Error('Invalid area description: columns cannot be negative');\n    }\n    if (_rows && _rows < 0) {\n        throw new Error('Invalid area description: rows cannot be negative');\n    }\n};\n\nvar _areaStartAndEnd = function _areaStartAndEnd(areaDesc) {\n    var size = [areaDesc[0] || 0, areaDesc[1] || 0];\n    var pos = [areaDesc[2] || 0, areaDesc[3] || 0];\n    var anchor = [areaDesc[4] || 0, areaDesc[5] || 0];\n    var start = (0, _utils.subtractPositions)(pos, anchor);\n    var end = (0, _utils.addPositions)(start, size);\n    return [start[0], start[1], end[0] - 1, end[1] - 1];\n};\n\nvar _contains = function _contains(innerAreaDesc, outerAreaDesc) {\n    var inner = _areaStartAndEnd(innerAreaDesc);\n    var outer = _areaStartAndEnd(outerAreaDesc);\n    return inner[0] >= outer[0] && inner[1] >= outer[1] && inner[2] <= outer[2] && inner[3] <= outer[3];\n};\n\n/**\n * @see https://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other\n * @private\n */\nvar _overlap = function _overlap(areaDesc1, areaDesc2) {\n    var area1 = _areaStartAndEnd(areaDesc1);\n    var area2 = _areaStartAndEnd(areaDesc2);\n    return area1[0] <= area2[2] && area2[0] <= area1[2] && area1[1] <= area2[3] && area2[1] <= area1[3];\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var grid = _clip(data, columns, rows, position, size);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: { clipAt: clipAt }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _clip = function _clip(data, columns, rows, position, size) {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error('Trying to clip data at an invalid position. Given: ' + position);\n    }\n    var endPoint = (0, _utils.addPositions)(position, size);\n    return (0, _utils.unflatten)(data, columns, rows).filter(function (row, r) {\n        return r >= position[1] && r < endPoint[1];\n    }).map(function (row) {\n        return row.filter(function (cell, c) {\n            return c >= position[0] && c < endPoint[0];\n        });\n    });\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numColumns() {\n        return state.columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        return (0, _utils.getColumn)((0, _utils.unflatten)(data, columns, rows), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (x < 0 || x > columns) {\n            throw new Error('Trying to add column at an invalid position. Given: ' + x);\n        }\n        if (column.length !== rows) {\n            throw new Error('Trying to add a column that contains an invalid amount of cells. Expected: ' + rows + ', Given: ' + column.length);\n        }\n        var grid = _utils2.default.unflatten(data, columns, rows).map(function (row, i) {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n        state.data = _utils2.default.flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (x < 0 || x >= columns) {\n            throw new Error('Trying to remove a column at an invalid position. Given: ' + x);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns, rows).map(function (row) {\n            return row.filter(function (v, c) {\n                return c !== x;\n            });\n        });\n        state.data = (0, _utils.flatten)(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addColumn: addColumn,\n            column: column,\n            numColumns: numColumns,\n            removeColumn: removeColumn\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callbackOrValue - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @param {*} [thisArg] Optional. Object to use as <code>this</code> when executing <code>callback</code>.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function find(callbackOrValue, thisArg) {\n        var data = state.data,\n            columns = state.columns;\n\n        var index = void 0;\n        if (typeof callbackOrValue === 'function') {\n            index = data.findIndex(function (v, i) {\n                return callbackOrValue.call(thisArg, v, (0, _utils.index2pos)(i, columns), context);\n            }, thisArg);\n        } else {\n            index = data.findIndex(function (v) {\n                return v === callbackOrValue;\n            }, thisArg);\n        }\n        return index >= 0 ? (0, _utils.index2pos)(index, columns) : undefined;\n    }\n\n    return { methods: { find: find } };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    var flipX = function flipX(xPos) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var grid = (0, _utils.unflatten)(data, columns, rows);\n        state.data = (0, _utils.flatten)(_flip(grid, xPos));\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var grid = (0, _utils.unflatten)(data, columns, rows);\n        state.data = (0, _utils.flatten)(grid.map(function (row) {\n            return _flip(row, yPos);\n        }));\n        return context;\n    }\n\n    return {\n        methods: { flipX: flipX, flipY: flipY }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _flip = function _flip(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    var limitedIdx = (0, _utils.limit)(index, 0, arr.length - 1);\n    var left = arr.filter(function (v, i) {\n        return i < limitedIdx;\n    });\n    var right = arr.filter(function (v, i) {\n        return i > limitedIdx;\n    });\n    return [].concat(_toConsumableArray(right.reverse()), [arr[limitedIdx]], _toConsumableArray(left.reverse()));\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (instance, state) {\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    function map(callback) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var newData = data.map(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), instance);\n        });\n        return (0, _index2.default)((0, _utils.unflatten)(newData, columns, rows));\n    }\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    function forEach(callback) {\n        var data = state.data,\n            columns = state.columns;\n\n        data.forEach(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), instance);\n        });\n        return instance;\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduce(callback, initialValue) {\n        var data = state.data,\n            columns = state.columns;\n\n        var reducer = function reducer(acc, v, i) {\n            return callback(acc, v, (0, _utils.index2pos)(i, columns), instance);\n        };\n        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n    }\n\n    /**\n     * Fill every cells with a value. You can either provide a value or a callback function to set the value for each cell.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {(iteratorCallback|*)} callbackOrValue - Either a fixed value for each cell or a callback function to fill each cell separately.\n     * @returns {gridl} The same gridl instance.\n     */\n    function fill(callbackOrValue) {\n        var data = state.data,\n            columns = state.columns;\n\n        if (typeof callbackOrValue === 'function') {\n            data.forEach(function (v, i) {\n                return data[i] = callbackOrValue(v, (0, _utils.index2pos)(i, columns), instance);\n            });\n        } else {\n            data.forEach(function (v, i) {\n                return data[i] = callbackOrValue;\n            });\n        }\n        return instance;\n    }\n\n    return {\n        methods: {\n            map: map,\n            forEach: forEach,\n            reduce: reduce,\n            fill: fill\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default']; /**\n                                      * @callback iteratorCallback\n                                      * @param {*} cell - The value of the current cell.\n                                      * @param {Array.<number>} position - The current position.\n                                      * @param {gridl} gridlInstance - The current gridl instance.\n                                      */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        state.data = _moveCell(data, columns, rows, from, to);\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error('Trying to move column from an invalid position. Given: ' + xFrom);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error('Trying to move column to an invalid position. Given: ' + xTo);\n        }\n        state.data = (0, _utils.flatten)((0, _utils.unflatten)(data, columns, rows).map(function (row) {\n            return _move(row, xFrom, xTo);\n        }));\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error('Trying to move row from an invalid position. Given: ' + yFrom);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error('Trying to move row to an invalid position. Given: ' + yTo);\n        }\n        state.data = (0, _utils.flatten)(_move((0, _utils.unflatten)(data, columns, rows), yFrom, yTo));\n        return context;\n    }\n\n    return {\n        methods: {\n            moveCell: moveCell,\n            moveColumn: moveColumn,\n            moveRow: moveRow\n        }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _move = function _move(data, fromIndex, toIndex) {\n    var cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nvar _moveCell = function _moveCell(data, columns, rows, from, to) {\n    var fromIndex = (0, _utils.pos2index)(from, columns);\n    var size = [columns, rows];\n    if (isNaN(fromIndex) || (0, _utils.isNotInArea)(size, from)) {\n        throw new Error('Trying to move cell from an invalid position. Given: [' + from + ']');\n    }\n    var toIndex = (0, _utils.pos2index)(to, columns);\n    if (isNaN(toIndex) || (0, _utils.isNotInArea)(size, to)) {\n        throw new Error('Trying to move cell to an invalid position. Given: [' + to + ']');\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    function rotate(steps) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var grid = _rotate((0, _utils.unflatten)(data, columns, rows), columns, steps);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return { methods: { rotate: rotate } };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _rotate(grid, columns, steps) {\n    var mod = steps % 4;\n    var option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, i).reverse();\n            });\n        case 2:\n            return grid.reverse().map(function (row, r) {\n                return row.reverse();\n            });\n        case 3:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, columns - 1 - i);\n            });\n        default:\n            throw new Error('Trying to rotate the grid with an invalid steps parameter. Given: ' + steps);\n    }\n}\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numRows() {\n        return state.rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        return getRow((0, _utils.unflatten)(data, columns, rows), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        var data = state.data,\n            rows = state.rows,\n            columns = state.columns;\n\n        if (y < 0 || y > rows) {\n            throw new Error('Trying to add row at an invalid position. Given: ' + y);\n        }\n        if (row.length !== columns) {\n            throw new Error('Trying to add a row that contains an invalid amount of cells. Expected: ' + columns + ', Given: ' + row.length);\n        }\n        var grid = (0, _utils.unflatten)(data, columns, rows);\n        grid.splice(y, 0, row);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        var data = state.data,\n            rows = state.rows,\n            columns = state.columns;\n\n        if (y < 0 || y >= rows) {\n            throw new Error('Trying to remove a row at an invalid position. Given: ' + y);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns, rows);\n        grid.splice(y, 1);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addRow: addRow,\n            numRows: numRows,\n            removeRow: removeRow,\n            row: row\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getRow = function getRow(data, y) {\n    return data[y];\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n    function size() {\n        var columns = state.columns,\n            rows = state.rows;\n\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array or imports a new data into the array. If you use it to import new grid data, make sure the new data has the same size.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} [newData] The new data you want to import as a two-dimensional grid array.\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array or the same gridl instance if you use it as a setter.\n     */\n    function data(newData) {\n        if (arguments.length) {\n            (0, _utils.validateGridArray)(newData);\n            state.rows = (0, _utils.countRows)(newData);\n            state.columns = (0, _utils.countColumns)(newData);\n            state.data = (0, _utils.flatten)(newData);\n            return context;\n        }\n        return (0, _utils.unflatten)(state.data, state.columns, state.rows);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return [].concat(_toConsumableArray(state.data));\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        return (0, _index2.default)((0, _utils.unflatten)(data, columns, rows));\n    }\n\n    return {\n        methods: {\n            size: size,\n            data: data,\n            list: list,\n            clone: clone\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error('Trying to swap columns from an invalid position. Given: ' + x1);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error('Trying to swap columns to an invalid position. Given: ' + x2);\n        }\n        var grid = (0, _utils.unflatten)(data, columns, rows).map(function (row) {\n            _swap(row, x1, x2);\n            return row;\n        });\n        state.data = (0, _utils.flatten)(grid);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error('Trying to swap rows from an invalid position. Given: ' + y1);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error('Trying to swap rows to an invalid position. Given: ' + y2);\n        }\n        state.data = (0, _utils.flatten)(_swap((0, _utils.unflatten)(data, columns, rows), y1, y2));\n        return context;\n    }\n\n    return {\n        methods: {\n            swapCells: swapCells,\n            swapColumns: swapColumns,\n            swapRows: swapRows\n        }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _swap = function _swap(arr, i1, i2) {\n    var tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nvar _swapCells = function _swapCells(data, columns, rows, position1, position2) {\n    var size = [columns, rows];\n    if ((0, _utils.isNotInArea)(size, position1) || (0, _utils.isNotInArea)(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    var index1 = (0, _utils.pos2index)(position1, columns);\n    var index2 = (0, _utils.pos2index)(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (!(0, _utils.isValidPositionFormat)(pos)) {\n            throw new Error('Trying to access value at an invalid position: ' + pos);\n        }\n        if (arguments.length < 2) {\n            return (0, _utils.getValueAt)(data, columns, pos);\n        }\n        (0, _utils.setValueAt)(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { methods: { valueAt: valueAt } };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nvar adjacences = Object.freeze({\n    ALL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT]),\n    ALL_CW: Object.freeze([_directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN, _directions2.default.DOWN_LEFT, _directions2.default.LEFT, _directions2.default.UP_LEFT]),\n    ALL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.UP_LEFT, _directions2.default.LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT, _directions2.default.RIGHT, _directions2.default.UP_RIGHT]),\n    ORTHOGONAL: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN]),\n    ORTHOGONAL_CW: Object.freeze([_directions2.default.UP, _directions2.default.RIGHT, _directions2.default.DOWN, _directions2.default.LEFT]),\n    ORTHOGONAL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.DOWN, _directions2.default.RIGHT]),\n    DIAGONAL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT]),\n    DIAGONAL_CW: Object.freeze([_directions2.default.UP_RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.UP_LEFT]),\n    DIAGONAL_CCW: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT, _directions2.default.UP_RIGHT])\n});\n\nexports.default = adjacences;\nmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// gridl.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8490715a6c1273bfa691","/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nexport const index2pos = (index, columns) => [index % columns, Math.floor(index / columns)];\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nexport const pos2index = (position, columns) => position && position[0] + position[1] * columns;\n\n/**\n * Count the number of rows in a two-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<any>>} array2D - The input array.\n * @returns {number} The number of rows.\n */\nexport const countRows = array2D => array2D.length || 0;\n\n/**\n * Count the number of columns in a two-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<any>>} array2D - The input array.\n * @returns {number} The number of columns.\n */\nexport const countColumns = array2D => (array2D && array2D[0] && array2D[0].length) || 0;\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nexport const flatten = array2D => array2D.reduce((res, row) => [...res, ...row], []);\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @param {number} rows - The number of rows the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nexport const unflatten = (array1D, columns, rows) => {\n    const res = [];\n    for (let r = 0; r < rows; r++) {\n        res[r] = [];\n        for (let c = 0; c < columns; c++) {\n            const pos = [c, r];\n            const i = pos2index(pos, columns);\n            res[r][c] = array1D[i];\n        }\n    }\n    return res;\n};\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nexport const addPositions = (p1, p2) => [\n    p1[0] + p2[0],\n    p1[1] + p2[1],\n];\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nexport const subtractPositions = (p1, p2) => [\n    p1[0] - p2[0],\n    p1[1] - p2[1],\n];\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nexport const limit = (value, min, max) => Math.max(Math.min(value, max), min);\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nexport const isNotInArea = (areaSize, position) => (\n    position[0] < 0 || position[0] >= areaSize[0] ||\n    position[1] < 0 || position[1] >= areaSize[1]\n);\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nexport const getValueAt = (data, columns, pos) => {\n    const index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nexport const setValueAt = (data, columns, rows, pos, value) => {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    const index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nexport const getColumn = (data, x) => {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(row => row[x]);\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nexport const isValidPositionFormat = position => {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return (Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]));\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nexport const validateGridArray = data => {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach((row, i) => {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with inconsistent number of columns.');\n        }\n        // if (row.length < 1) {\n        //     throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        // }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nconst utils = {\n    countColumns,\n    countRows,\n    flatten,\n    isValidPositionFormat,\n    unflatten,\n    index2pos,\n    pos2index,\n    addPositions,\n    subtractPositions,\n    limit,\n    isNotInArea,\n    getColumn,\n    getValueAt,\n    setValueAt,\n    validateGridArray,\n};\n\nexport default utils;\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import utils from './utils';\nimport generators from './generators';\nimport corePlugins from './plugins';\nimport directions from './directions';\nimport adjacences from './adjacences';\n\nconst { flatten, validateGridArray, countColumns, countRows } = utils;\n\nconst usedPlugins = [];\n\nfunction registerPlugins(state) {\n    const register = ([key, pluginFactory]) => {\n        const plugin = pluginFactory(this, state);\n        const type = typeof plugin;\n\n        // plugin is just a function\n        if (type === 'function') {\n            this[key] = plugin;\n        }\n\n        // plugin returns multiple functions with a namespace\n        else if (type === 'object' && plugin.methods && plugin.namespace) {\n            this[key] = plugin.methods;\n        }\n\n        // plugin returns multiple functions without a namespace\n        else if (type === 'object' && plugin.methods) {\n            Object.entries(plugin.methods).forEach(([k, func]) => {\n                this[k] = func;\n            });\n        }\n    };\n\n    // Object.entries(plugins).forEach(register);\n    usedPlugins.forEach(register);\n}\n\n/**\n * @class\n * @private\n */\nfunction gridl(data) {\n\n    // validate incoming data\n    validateGridArray(data); // TODO: support no rows and columns, default to to [[]]\n\n    // create initial state\n    const initialState = {\n        rows: countRows(data),\n        columns: countColumns(data),\n        data: flatten(data), // TODO: if no data is provided default to [[]]\n    };\n\n    // register plugins with initial state\n    registerPlugins.call(this, initialState);\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same number of columns.\n */\nconst gridlFactory = data => new gridl(data);\n\n/**\n * Register a plugin.\n *\n * @param {string} id - An unique ID to identify the plugin.\n * @param {Object} plugin - The plugin itself.\n */\ngridlFactory.use = (id, plugin) => {\n    usedPlugins.push([id, plugin]);\n};\n\n// register core plugins\nObject.entries(corePlugins).forEach(([key, plugin]) => gridlFactory.use(key, plugin));\n\nexport { utils, generators, adjacences, directions};\n\nexport default gridlFactory;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nconst directions = Object.freeze({\n    UP:         Object.freeze([ 0, -1]),\n    UP_RIGHT:   Object.freeze([ 1, -1]),\n    RIGHT:      Object.freeze([ 1,  0]),\n    DOWN_RIGHT: Object.freeze([ 1,  1]),\n    DOWN:       Object.freeze([ 0,  1]),\n    DOWN_LEFT:  Object.freeze([-1,  1]),\n    LEFT:       Object.freeze([-1,  0]),\n    UP_LEFT:    Object.freeze([-1, -1]),\n});\n\nexport default directions;\n\n\n\n// WEBPACK FOOTER //\n// ./src/directions.js","import gridl from './index';\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nexport function makeDataGrid(columns, rows, callback = () => null) {\n    const parsedColumns = parseInt(columns);\n    const parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error(`You need to specify at least one column. Given: ${columns}`);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error(`You need to specify at least one row. Given: ${rows}`);\n    }\n    return Array.from({ length: parsedRows }, (vr, row) => (\n        Array.from({ length: parsedColumns }, (vc, column) => (\n            callback({ column, row })\n        ))\n    ));\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nexport function makeDataList(length, callback = () => null) {\n    const parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error(`Trying to make a list with an invalid length. Given: ${length}`);\n    }\n    return Array.from({ length: parsedLength }, (v, i) => callback(i));\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nexport function makeGridl(numColumns, numRows, callback) {\n    return gridl(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexport default {\n    makeGridl,\n    makeDataGrid,\n    makeDataList,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/generators.js","import adjacence from './adjacence';\nimport area from './area';\nimport clipping from './clipping';\nimport columns from './columns';\nimport finding from './finding';\nimport flip from './flipping';\nimport iterator from './iterator';\nimport moving from './moving';\nimport rotating from './rotating';\nimport rows from './rows';\nimport state from './state';\nimport swapping from './swapping';\nimport value from './value';\n\nexport default {\n    adjacence,\n    area,\n    clipping,\n    columns,\n    finding,\n    flip,\n    iterator,\n    moving,\n    rotating,\n    rows,\n    state,\n    swapping,\n    value,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/index.js","import gridl, {adjacences} from '../index';\nimport { unflatten, addPositions, isNotInArea } from '../utils';\n\nconst _adjacentCells = (grid, position, adjacence, gridSize = null) => {\n    return adjacence.reduce((res, direction) => {\n        const absPos = addPositions(position, direction);\n        const value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return isNotInArea(gridSize, absPos) ? res : [...res, value];\n        }\n        else {\n            return [...res, value];\n        }\n    }, []);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCellsAt(position, adjacence = adjacences.ALL, includeOutsideValues = false) {\n        const { data, columns, rows } = state;\n        const gridSize = !includeOutsideValues && [columns, rows];\n        const grid = unflatten(data, columns, rows);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        methods: {\n            adjacentCellsAt,\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/adjacence.js","import gridl from '../index';\nimport {\n    setValueAt,\n    subtractPositions,\n    index2pos,\n    flatten,\n    unflatten,\n    addPositions,\n    getValueAt,\n    countRows,\n    countColumns,\n} from '../utils';\n\nconst _getAreaAt = (data, columns, rows, position, size, anchor = [0,0]) => {\n    const posTmp = subtractPositions(position, anchor);\n    const end = [\n        Math.min(posTmp[0] + size[0], columns),\n        Math.min(posTmp[1] + size[1], rows),\n    ];\n    const pos = [\n        Math.max(0, posTmp[0]),\n        Math.max(0, posTmp[1]),\n    ];\n    const area = [];\n    for (let r = pos[1]; r < end[1]; r++) {\n        const rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (let c = pos[0]; c < end[0]; c++) {\n            const cArea = c - pos[0];\n            area[rArea][cArea] = getValueAt(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nconst _setAreaAt = (data, columns, rows, position, area, anchor = [0,0]) => {\n    const pos = subtractPositions(position, anchor);\n    area.forEach((row, r) => {\n        const targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach((cell, c) => {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            setValueAt(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nconst _validateAreaMember = member => member === undefined || typeof member === 'number';\n\nconst _validateAreaDescription = areaDescription => {\n    if (areaDescription.length > 6) {\n        throw new Error('Invalid area description: too many fields');\n    }\n    const [_columns = 0, _rows = 0, _x = 0, _y = 0, _ax = 0, _ay = 0] = areaDescription;\n    if (!_validateAreaMember(_columns)) {\n        throw new Error('Invalid area description: column is not a number');\n    }\n    if (!_validateAreaMember(_rows)) {\n        throw new Error('Invalid area description: row is not a number');\n    }\n    if (!_validateAreaMember(_x)) {\n        throw new Error('Invalid area description: x is not a number');\n    }\n    if (!_validateAreaMember(_y)) {\n        throw new Error('Invalid area description: y is not a number');\n    }\n    if (!_validateAreaMember(_ax)) {\n        throw new Error('Invalid area description: anchorX is not a number');\n    }\n    if (!_validateAreaMember(_ay)) {\n        throw new Error('Invalid area description: anchorY is not a number');\n    }\n    if (_columns && _columns < 0) {\n        throw new Error('Invalid area description: columns cannot be negative');\n    }\n    if (_rows && _rows < 0) {\n        throw new Error('Invalid area description: rows cannot be negative');\n    }\n};\n\nconst _areaStartAndEnd = areaDesc => {\n    const size   = [areaDesc[0] || 0, areaDesc[1] || 0];\n    const pos    = [areaDesc[2] || 0, areaDesc[3] || 0];\n    const anchor = [areaDesc[4] || 0, areaDesc[5] || 0];\n    const start  = subtractPositions(pos, anchor);\n    const end    = addPositions(start, size);\n    return [start[0], start[1], end[0] - 1, end[1] - 1];\n};\n\nconst _contains = (innerAreaDesc, outerAreaDesc) => {\n    const inner = _areaStartAndEnd(innerAreaDesc);\n    const outer = _areaStartAndEnd(outerAreaDesc);\n    return (\n        inner[0] >= outer[0] &&\n        inner[1] >= outer[1] &&\n        inner[2] <= outer[2] &&\n        inner[3] <= outer[3]\n    );\n};\n\n/**\n * @see https://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other\n * @private\n */\nconst _overlap = (areaDesc1, areaDesc2) => {\n    const area1 = _areaStartAndEnd(areaDesc1);\n    const area2 = _areaStartAndEnd(areaDesc2);\n    return (\n        area1[0] <= area2[2] &&\n        area2[0] <= area1[2] &&\n        area1[1] <= area2[3] &&\n        area2[1] <= area1[3]\n    );\n};\n\nexport default function(instance, state) {\n\n    const area = areaDescription => {\n        _validateAreaDescription(areaDescription);\n\n        // input values\n        const [_columns = 0, _rows = 0, _x = 0, _y = 0, _ax = 0, _ay = 0] = areaDescription;\n        const _position = [_x, _y];\n        const _anchor = [_ax, _ay];\n        const _size = [_columns, _rows];\n\n        // calculated values\n        const data = _getAreaAt(state.data, state.columns, state.rows, _position, _size, _anchor);\n        const columns = countColumns(data);\n        const rows = countRows(data);\n        const size = [columns, rows];\n\n        // area api\n        const subgrid = gridl(data);\n        const api = {\n            numRows: () => rows,\n            numColumns: () => columns,\n            size: () => size,\n            position: () => _position,\n            anchor: () => _anchor,\n            localToGlobal: (localPosition) => addPositions(api.position(), localPosition),\n            valueAt: function(localPosition, value) {\n                return arguments.length > 1 ?\n                    subgrid.valueAt(localPosition, value) :\n                    subgrid.valueAt(localPosition);\n            },\n            data: function(value) {\n                if (arguments.length > 0) {\n                    const _newColumns = countColumns(value);\n                    const _newRows = countRows(value);\n                    if (_newRows !== rows || _newColumns !== columns) {\n                        throw new Error('New area data has an invalid size.');\n                    }\n                    subgrid.data(value);\n                    return api;\n                }\n                return subgrid.data();\n            },\n            apply: () => {\n                _setAreaAt(state.data, state.columns, state.rows, _position, subgrid.data(), _anchor);\n                return instance;\n            },\n            parent: () => instance,\n            reduce: function(callback, initialValue) {\n                const reducer = (acc, v, i) => {\n                    const local = index2pos(i, columns);\n                    return callback(acc, v, local, api);\n                };\n                return arguments.length < 1 ?\n                    flatten(data).reduce(reducer) :\n                    flatten(data).reduce(reducer, initialValue);\n            },\n            map: function(callback, thisArg) {\n                const mapper = (v, i) => {\n                    const local = index2pos(i, columns);\n                    return callback.call(thisArg, v, local, api);\n                };\n                // TODO: looks too complicated (flatten -> unflatten)\n                const newData = flatten(data).map(mapper, thisArg);\n                // return a copy with the new data\n                return area(areaDescription).data(unflatten(newData, columns, rows));\n            },\n            fill: (callbackOrValue, thisArg) => {\n                if (typeof callbackOrValue === 'function') {\n                    subgrid.fill((v, pos) => callbackOrValue.call(thisArg, v, pos, api));\n                }\n                else {\n                    subgrid.fill(callbackOrValue);\n                }\n                return api;\n            },\n            find: (callbackOrValue, thisArg) => {\n                if (typeof callbackOrValue === 'function') {\n                    return subgrid.find((v, pos) => callbackOrValue.call(thisArg, v, pos, api));\n                }\n                return subgrid.find(v => v === callbackOrValue);\n            },\n            forEach: (callback, thisArg) => {\n                const iterator = (v, i) => {\n                    const local = index2pos(i, columns);\n                    return callback.call(thisArg, v, local, api);\n                };\n                flatten(data).forEach(iterator, thisArg);\n                return api;\n            },\n            description: () => [columns, rows, _x, _y, _ax, _ay],\n            isInside: otherAreaDescription => {\n                _validateAreaDescription(otherAreaDescription);\n                return _contains(api.description(), otherAreaDescription);\n            },\n            contains: otherAreaDescription => {\n                _validateAreaDescription(otherAreaDescription);\n                return _contains(otherAreaDescription, api.description());\n            },\n            intersectsWith: otherAreaDescription => {\n                _validateAreaDescription(otherAreaDescription);\n                return _overlap(api.description(), otherAreaDescription);\n            },\n        };\n        return api;\n    };\n\n    return {\n        methods: { area },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/area.js","import { addPositions, flatten, unflatten } from '../utils';\n\nconst _clip = (data, columns, rows, position, size) => {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error(`Trying to clip data at an invalid position. Given: ${position}`);\n    }\n    const endPoint = addPositions(position, size);\n    return unflatten(data, columns, rows)\n        .filter((row, r) => r >= position[1] && r < endPoint[1])\n        .map(row => row.filter((cell, c) => c >= position[0] && c < endPoint[0]));\n};\n\nexport default function(context, state) {\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        const { data, columns, rows } = state;\n        const grid = _clip(data, columns, rows, position, size);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: { clipAt },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/clipping.js","import gridl from '../index';\nimport { flatten, unflatten, getColumn } from '../utils';\nimport utils from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numColumns() {\n        return state.columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        const { data, columns, rows } = state;\n        return getColumn(unflatten(data, columns, rows), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        const { data, columns, rows } = state;\n        if (x < 0 || x > columns) {\n            throw new Error(`Trying to add column at an invalid position. Given: ${x}`);\n        }\n        if (column.length !== rows) {\n            throw new Error(`Trying to add a column that contains an invalid amount of cells. Expected: ${rows}, Given: ${column.length}`);\n        }\n        const grid = utils.unflatten(data, columns, rows).map((row, i) => {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n        state.data = utils.flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        const { data, columns, rows } = state;\n        if (x < 0 || x >= columns) {\n            throw new Error(`Trying to remove a column at an invalid position. Given: ${x}`);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns, rows).map(row => row.filter((v, c) => c !== x));\n        state.data = flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addColumn,\n            column,\n            numColumns,\n            removeColumn,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/columns.js","import { index2pos } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callbackOrValue - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @param {*} [thisArg] Optional. Object to use as <code>this</code> when executing <code>callback</code>.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function find(callbackOrValue, thisArg) {\n        const { data, columns } = state;\n        let index;\n        if (typeof callbackOrValue === 'function') {\n            index = data.findIndex((v, i) => callbackOrValue.call(thisArg, v, index2pos(i, columns), context), thisArg);\n        }\n        else {\n            index = data.findIndex((v) => v === callbackOrValue, thisArg);\n        }\n        return (index >= 0) ? index2pos(index, columns) : undefined;\n    }\n\n    return { methods: { find } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/finding.js","import { unflatten, flatten, limit } from '../utils';\n\nconst _flip = (arr, index) => {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    const limitedIdx = limit(index, 0, arr.length - 1);\n    const left = arr.filter((v, i) => i < limitedIdx);\n    const right = arr.filter((v, i) => i > limitedIdx);\n    return [\n        ...right.reverse(),\n        arr[limitedIdx],\n        ...left.reverse(),\n    ];\n};\n\nexport default function(context, state) {\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    const flipX = (xPos) => {\n        const { data, columns, rows } = state;\n        const grid = unflatten(data, columns, rows);\n        state.data = flatten(_flip(grid, xPos));\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        const { data, columns, rows } = state;\n        const grid = unflatten(data, columns, rows);\n        state.data = flatten(grid.map(row => _flip(row, yPos)));\n        return context;\n    }\n\n    return {\n        methods: { flipX, flipY },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/flipping.js","/**\n * @callback iteratorCallback\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\nimport gridl from '../index';\nimport { index2pos, unflatten } from '../utils';\n\nexport default function(instance, state) {\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    function map(callback) {\n        const { data, columns, rows } = state;\n        const newData = data.map((v, i) => callback(v, index2pos(i, columns), instance));\n        return gridl(unflatten(newData, columns, rows));\n    }\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    function forEach(callback) {\n        const { data, columns } = state;\n        data.forEach((v, i) => callback(v, index2pos(i, columns), instance));\n        return instance;\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduce(callback, initialValue) {\n        const { data, columns } = state;\n        const reducer = (acc, v, i) => callback(acc, v, index2pos(i, columns), instance);\n        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n    }\n\n    /**\n     * Fill every cells with a value. You can either provide a value or a callback function to set the value for each cell.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {(iteratorCallback|*)} callbackOrValue - Either a fixed value for each cell or a callback function to fill each cell separately.\n     * @returns {gridl} The same gridl instance.\n     */\n    function fill(callbackOrValue) {\n        const { data, columns } = state;\n        if (typeof callbackOrValue === 'function') {\n            data.forEach((v, i) => data[i] = callbackOrValue(v, index2pos(i, columns), instance));\n        }\n        else {\n            data.forEach((v, i) => data[i] = callbackOrValue);\n        }\n        return instance;\n    }\n\n    return {\n        methods: {\n            map,\n            forEach,\n            reduce,\n            fill,\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/iterator.js","import {\n    addPositions,\n    flatten,\n    isNotInArea,\n    pos2index,\n    unflatten,\n} from '../utils';\n\nconst _move = (data, fromIndex, toIndex) => {\n    const cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nconst _moveCell = (data, columns, rows, from, to) => {\n    const fromIndex = pos2index(from, columns);\n    const size = [columns, rows];\n    if (isNaN(fromIndex) || isNotInArea(size, from)) {\n        throw new Error(`Trying to move cell from an invalid position. Given: [${from}]`);\n    }\n    const toIndex = pos2index(to, columns);\n    if (isNaN(toIndex) || isNotInArea(size, to)) {\n        throw new Error(`Trying to move cell to an invalid position. Given: [${to}]`);\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        const { data, columns, rows } = state;\n        state.data = _moveCell(data, columns, rows, from, to);\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        const { data, columns, rows } = state;\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error(`Trying to move column from an invalid position. Given: ${xFrom}`);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error(`Trying to move column to an invalid position. Given: ${xTo}`);\n        }\n        state.data = flatten(unflatten(data, columns, rows).map(row => _move(row, xFrom, xTo)));\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        const { data, columns, rows } = state;\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error(`Trying to move row from an invalid position. Given: ${yFrom}`);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error(`Trying to move row to an invalid position. Given: ${yTo}`);\n        }\n        state.data = flatten(_move(unflatten(data, columns, rows), yFrom, yTo));\n        return context;\n    }\n\n    return {\n        methods: {\n            moveCell,\n            moveColumn,\n            moveRow,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/moving.js","import { getColumn, unflatten, flatten } from '../utils';\n\nfunction _rotate(grid, columns, steps) {\n    const mod = steps % 4;\n    const option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, i).reverse());\n        case 2:\n            return grid.reverse().map((row, r) => row.reverse());\n        case 3:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, columns - 1 - i));\n        default:\n            throw new Error(`Trying to rotate the grid with an invalid steps parameter. Given: ${steps}`);\n    }\n}\n\nexport default function(context, state) {\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    function rotate(steps) {\n        const { data, columns, rows } = state;\n        const grid = _rotate(unflatten(data, columns, rows), columns, steps);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return { methods: { rotate } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rotating.js","import gridl from '../index';\nimport { flatten, unflatten } from '../utils';\n\nconst getRow = (data, y) => data[y];\n\nexport default function(context, state) {\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numRows() {\n        return state.rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        const { data, columns, rows } = state;\n        return getRow(unflatten(data, columns, rows), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        const { data, rows, columns} = state;\n        if (y < 0 || y > rows) {\n            throw new Error(`Trying to add row at an invalid position. Given: ${y}`);\n        }\n        if (row.length !== columns) {\n            throw new Error(`Trying to add a row that contains an invalid amount of cells. Expected: ${columns}, Given: ${row.length}`);\n        }\n        const grid = unflatten(data, columns, rows);\n        grid.splice(y, 0, row);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        const { data, rows, columns} = state;\n        if (y < 0 || y >= rows) {\n            throw new Error(`Trying to remove a row at an invalid position. Given: ${y}`);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns, rows);\n        grid.splice(y, 1);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addRow,\n            numRows,\n            removeRow,\n            row,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rows.js","import gridl from '../index';\nimport { flatten, unflatten, validateGridArray, countColumns, countRows } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n    function size() {\n        const { columns, rows } = state;\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array or imports a new data into the array. If you use it to import new grid data, make sure the new data has the same size.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} [newData] The new data you want to import as a two-dimensional grid array.\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array or the same gridl instance if you use it as a setter.\n     */\n    function data(newData) {\n        if (arguments.length) {\n            validateGridArray(newData);\n            state.rows = countRows(newData);\n            state.columns = countColumns(newData);\n            state.data = flatten(newData);\n            return context;\n        }\n        return unflatten(state.data, state.columns, state.rows);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return ([...state.data]);\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        const { data, columns, rows } = state;\n        return gridl(unflatten(data, columns, rows));\n    }\n\n    return {\n        methods: {\n            size,\n            data,\n            list,\n            clone,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/state.js","import { flatten, isNotInArea, pos2index, unflatten } from '../utils';\n\nconst _swap = (arr, i1, i2) => {\n    const tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nconst _swapCells = (data, columns, rows, position1, position2) => {\n    const size = [columns, rows];\n    if (isNotInArea(size, position1) || isNotInArea(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    const index1 = pos2index(position1, columns);\n    const index2 = pos2index(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        const { data, columns, rows } = state;\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        const { data, columns, rows } = state;\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error(`Trying to swap columns from an invalid position. Given: ${x1}`);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error(`Trying to swap columns to an invalid position. Given: ${x2}`);\n        }\n        const grid = unflatten(data, columns, rows).map(row => {\n            _swap(row, x1, x2);\n            return row;\n        });\n        state.data = flatten(grid);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        const { data, columns, rows } = state;\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error(`Trying to swap rows from an invalid position. Given: ${y1}`);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error(`Trying to swap rows to an invalid position. Given: ${y2}`);\n        }\n        state.data = flatten(_swap(unflatten(data, columns, rows), y1, y2));\n        return context;\n    }\n\n    return {\n        methods: {\n            swapCells,\n            swapColumns,\n            swapRows,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/swapping.js","import { getValueAt, isValidPositionFormat, setValueAt } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        const { data, columns, rows } = state;\n        if (!isValidPositionFormat(pos)) {\n            throw new Error(`Trying to access value at an invalid position: ${pos}`);\n        }\n        if (arguments.length < 2) {\n            return getValueAt(data, columns, pos);\n        }\n        setValueAt(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { methods: { valueAt } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/value.js","import directions from './directions';\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nconst adjacences = Object.freeze({\n    ALL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n    ]),\n    ALL_CW: Object.freeze([\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN,\n        directions.DOWN_LEFT,\n        directions.LEFT,\n        directions.UP_LEFT,\n    ]),\n    ALL_CCW: Object.freeze([\n        directions.UP,\n        directions.UP_LEFT,\n        directions.LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n        directions.RIGHT,\n        directions.UP_RIGHT,\n    ]),\n    ORTHOGONAL: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN,\n    ]),\n    ORTHOGONAL_CW: Object.freeze([\n        directions.UP,\n        directions.RIGHT,\n        directions.DOWN,\n        directions.LEFT,\n    ]),\n    ORTHOGONAL_CCW: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.DOWN,\n        directions.RIGHT,\n    ]),\n    DIAGONAL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP_RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n    ]),\n    DIAGONAL_CW: Object.freeze([\n        directions.UP_RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN_LEFT,\n        directions.UP_LEFT,\n    ]),\n    DIAGONAL_CCW: Object.freeze([\n        directions.UP_LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n        directions.UP_RIGHT,\n    ]),\n});\n\nexport default adjacences;\n\n\n// WEBPACK FOOTER //\n// ./src/adjacences.js"],"sourceRoot":""}