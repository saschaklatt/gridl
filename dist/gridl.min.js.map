{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gridl.min.js","webpack:///webpack/bootstrap 5a4d5fc43e8eb1e23d8d","webpack:///./src/utils.js","webpack:///./src/index.js","webpack:///./src/directions.js","webpack:///./src/generators.js","webpack:///./src/plugins/index.js","webpack:///./src/plugins/adjacence.js","webpack:///./src/plugins/area.js","webpack:///./src/plugins/clipping.js","webpack:///./src/plugins/columns.js","webpack:///./src/plugins/finding.js","webpack:///./src/plugins/flipping.js","webpack:///./src/plugins/iterator.js","webpack:///./src/plugins/moving.js","webpack:///./src/plugins/navigating.js","webpack:///./src/plugins/rotating.js","webpack:///./src/plugins/rows.js","webpack:///./src/plugins/state.js","webpack:///./src/plugins/swapping.js","webpack:///./src/plugins/value.js","webpack:///./src/adjacences.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","value","index2pos","index","columns","Math","floor","pos2index","position","flatten","array2D","reduce","res","row","concat","unflatten","array1D","cell","pos","addPositions","p1","p2","subtractPositions","limit","min","max","isNotInArea","areaSize","getValueAt","data","isNaN","setValueAt","rows","getColumn","x","map","isValidPositionFormat","Number","isSafeInteger","validateGridArray","Error","forEach","utils","default","_interopRequireDefault","obj","gridl","fn","_this","_state","_stateProvider","getState","setState","newState","entries","_ref","_ref2","_slicedToArray","key","_ref3","_ref4","pluginFactory","plugin","type","_typeof","_ref5","_ref6","k","func","directions","adjacences","generators","undefined","Symbol","iterator","constructor","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","push","err","TypeError","_utils","_utils2","_generators","_generators2","_plugins","_plugins2","_directions","_directions2","_adjacences","_adjacences2","gridlFactory","freeze","UP","UP_RIGHT","RIGHT","DOWN_RIGHT","DOWN","DOWN_LEFT","LEFT","UP_LEFT","makeDataGrid","callback","arguments","parsedColumns","parseInt","parsedRows","vr","vc","column","makeDataList","parsedLength","v","makeGridl","numColumns","numRows","_index2","_index","_adjacence","_adjacence2","_area","_area2","_clipping","_clipping2","_columns","_columns2","_finding","_finding2","_flipping","_flipping2","_iterator","_iterator2","_moving","_moving2","_navigating","_navigating2","_rotating","_rotating2","_rows","_rows2","_state2","_swapping","_swapping2","_value","_value2","adjacence","area","clipping","finding","flipping","moving","navigating","rotating","state","swapping","_adjacentCells","grid","gridSize","direction","absPos","context","stateProvider","adjacentCellsAt","ALL","includeOutsideValues","adjacentCells","_stateProvider$getSta","_reduceAreaAt","api","size","initialValue","hasInitialValue","reducer","acc","local","global","flattenedArea","_getAreaAt","areaFits","anchor","_checkAreaFitsAt","areaFitsAt","getArea","getAreaAt","setArea","_setAreaAt","setAreaAt","findInArea","flat","areaIndex","findIndex","areaColumns","posInArea","reduceAreaAt","reduceArea","posTmp","end","r","rArea","cArea","fitsHorizontally","fitsVertically","targetPos","_clip","clip","clipAt","endPoint","filter","addColumn","splice","removeColumn","find","_flip","reverse","limitedIdx","left","flipY","yPos","flipX","xPos","mirrorX","mirrorY","newData","moveAbs","to","_moveCell","moveCell","moveColumn","xFrom","xTo","_move","moveRel","moveRow","yFrom","yTo","fromIndex","toIndex","goto","walk","_rotate","steps","mod","rotate","y","getRow","addRow","removeRow","list","clone","swapCell","otherPosition","_swapCells","swapCells","position1","position2","swapColumns","x1","x2","_swap","swapRows","y1","y2","i1","i2","tmp","index1","index2","valueAt","ALL_CW","ALL_CCW","ORTHOGONAL","ORTHOGONAL_CW","ORTHOGONAL_CCW","DIAGONAL","DIAGONAL_CW","DIAGONAL_CCW"],"mappings":"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","file":"gridl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nvar index2pos = exports.index2pos = function index2pos(index, columns) {\n    return [index % columns, Math.floor(index / columns)];\n};\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nvar pos2index = exports.pos2index = function pos2index(position, columns) {\n    return position && position[0] + position[1] * columns;\n};\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nvar flatten = exports.flatten = function flatten(array2D) {\n    return array2D.reduce(function (res, row) {\n        return [].concat(_toConsumableArray(res), _toConsumableArray(row));\n    }, []);\n};\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nvar unflatten = exports.unflatten = function unflatten(array1D, columns) {\n    return array1D.reduce(function (res, cell, index) {\n        var pos = index2pos(index, columns);\n        if (!res[pos[1]]) {\n            res[pos[1]] = [];\n        }\n        res[pos[1]][pos[0]] = cell;\n        return res;\n    }, []);\n};\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nvar addPositions = exports.addPositions = function addPositions(p1, p2) {\n    return [p1[0] + p2[0], p1[1] + p2[1]];\n};\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nvar subtractPositions = exports.subtractPositions = function subtractPositions(p1, p2) {\n    return [p1[0] - p2[0], p1[1] - p2[1]];\n};\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nvar limit = exports.limit = function limit(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n};\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nvar isNotInArea = exports.isNotInArea = function isNotInArea(areaSize, position) {\n    return position[0] < 0 || position[0] >= areaSize[0] || position[1] < 0 || position[1] >= areaSize[1];\n};\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nvar getValueAt = exports.getValueAt = function getValueAt(data, columns, pos) {\n    var index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nvar setValueAt = exports.setValueAt = function setValueAt(data, columns, rows, pos, value) {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    var index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nvar getColumn = exports.getColumn = function getColumn(data, x) {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(function (row) {\n            return row[x];\n        });\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nvar isValidPositionFormat = exports.isValidPositionFormat = function isValidPositionFormat(position) {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]);\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nvar validateGridArray = exports.validateGridArray = function validateGridArray(data) {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach(function (row, i) {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with different row lengths.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nvar utils = {\n    flatten: flatten,\n    isValidPositionFormat: isValidPositionFormat,\n    unflatten: unflatten,\n    index2pos: index2pos,\n    pos2index: pos2index,\n    addPositions: addPositions,\n    subtractPositions: subtractPositions,\n    limit: limit,\n    isNotInArea: isNotInArea,\n    getColumn: getColumn,\n    getValueAt: getValueAt,\n    setValueAt: setValueAt,\n    validateGridArray: validateGridArray\n};\n\nexports.default = utils;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.directions = exports.adjacences = exports.generators = exports.utils = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _generators = __webpack_require__(3);\n\nvar _generators2 = _interopRequireDefault(_generators);\n\nvar _plugins = __webpack_require__(4);\n\nvar _plugins2 = _interopRequireDefault(_plugins);\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nvar _adjacences = __webpack_require__(19);\n\nvar _adjacences2 = _interopRequireDefault(_adjacences);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar flatten = _utils2.default.flatten,\n    validateGridArray = _utils2.default.validateGridArray;\n\n/**\n * @class\n * @private\n */\n\nfunction gridl(fn, data) {\n    var _this = this;\n\n    // validate incoming data\n    validateGridArray(data);\n\n    var _state = {};\n\n    var _stateProvider = {\n        getState: function getState() {\n            return _state;\n        },\n        setState: function setState(newState) {\n            // set state\n            Object.entries(newState).forEach(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    key = _ref2[0],\n                    value = _ref2[1];\n\n                return _state[key] = value;\n            });\n\n            // update plugins\n            Object.entries(fn).forEach(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    key = _ref4[0],\n                    pluginFactory = _ref4[1];\n\n                var plugin = pluginFactory(_this, _stateProvider);\n                var type = typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin);\n\n                // plugin is just a function\n                if (type === 'function') {\n                    _this[key] = plugin;\n                }\n\n                // plugin returns multiple functions bundled together in an object\n                else if (type === 'object') {\n                        Object.entries(plugin).forEach(function (_ref5) {\n                            var _ref6 = _slicedToArray(_ref5, 2),\n                                k = _ref6[0],\n                                func = _ref6[1];\n\n                            _this[k] = func;\n                        });\n                    }\n            });\n        }\n    };\n\n    // set initial state\n    _stateProvider.setState({\n        rows: data.length,\n        columns: data[0].length,\n        data: flatten(data),\n        position: [0, 0]\n    });\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n */\nvar gridlFactory = function gridlFactory(data) {\n    return new gridl(gridlFactory.fn, data);\n};\ngridlFactory.fn = _plugins2.default;\n\nexports.utils = _utils2.default;\nexports.generators = _generators2.default;\nexports.adjacences = _adjacences2.default;\nexports.directions = _directions2.default;\nexports.default = gridlFactory;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nvar directions = Object.freeze({\n  UP: Object.freeze([0, -1]),\n  UP_RIGHT: Object.freeze([1, -1]),\n  RIGHT: Object.freeze([1, 0]),\n  DOWN_RIGHT: Object.freeze([1, 1]),\n  DOWN: Object.freeze([0, 1]),\n  DOWN_LEFT: Object.freeze([-1, 1]),\n  LEFT: Object.freeze([-1, 0]),\n  UP_LEFT: Object.freeze([-1, -1])\n});\n\nexports.default = directions;\nmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.makeDataGrid = makeDataGrid;\nexports.makeDataList = makeDataList;\nexports.makeGridl = makeGridl;\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nfunction makeDataGrid(columns, rows) {\n    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n        return null;\n    };\n\n    var parsedColumns = parseInt(columns);\n    var parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error('You need to specify at least one column. Given: ' + columns);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error('You need to specify at least one row. Given: ' + rows);\n    }\n    return Array.from({ length: parsedRows }, function (vr, row) {\n        return Array.from({ length: parsedColumns }, function (vc, column) {\n            return callback({ column: column, row: row });\n        });\n    });\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nfunction makeDataList(length) {\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return null;\n    };\n\n    var parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error('Trying to make a list with an invalid length. Given: ' + length);\n    }\n    return Array.from({ length: parsedLength }, function (v, i) {\n        return callback(i);\n    });\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nfunction makeGridl(numColumns, numRows, callback) {\n    return (0, _index2.default)(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexports.default = {\n    makeGridl: makeGridl,\n    makeDataGrid: makeDataGrid,\n    makeDataList: makeDataList\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _adjacence = __webpack_require__(5);\n\nvar _adjacence2 = _interopRequireDefault(_adjacence);\n\nvar _area = __webpack_require__(6);\n\nvar _area2 = _interopRequireDefault(_area);\n\nvar _clipping = __webpack_require__(7);\n\nvar _clipping2 = _interopRequireDefault(_clipping);\n\nvar _columns = __webpack_require__(8);\n\nvar _columns2 = _interopRequireDefault(_columns);\n\nvar _finding = __webpack_require__(9);\n\nvar _finding2 = _interopRequireDefault(_finding);\n\nvar _flipping = __webpack_require__(10);\n\nvar _flipping2 = _interopRequireDefault(_flipping);\n\nvar _iterator = __webpack_require__(11);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _moving = __webpack_require__(12);\n\nvar _moving2 = _interopRequireDefault(_moving);\n\nvar _navigating = __webpack_require__(13);\n\nvar _navigating2 = _interopRequireDefault(_navigating);\n\nvar _rotating = __webpack_require__(14);\n\nvar _rotating2 = _interopRequireDefault(_rotating);\n\nvar _rows = __webpack_require__(15);\n\nvar _rows2 = _interopRequireDefault(_rows);\n\nvar _state = __webpack_require__(16);\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _swapping = __webpack_require__(17);\n\nvar _swapping2 = _interopRequireDefault(_swapping);\n\nvar _value = __webpack_require__(18);\n\nvar _value2 = _interopRequireDefault(_value);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    adjacence: _adjacence2.default,\n    area: _area2.default,\n    clipping: _clipping2.default,\n    columns: _columns2.default,\n    finding: _finding2.default,\n    flipping: _flipping2.default,\n    iterator: _iterator2.default,\n    moving: _moving2.default,\n    navigating: _navigating2.default,\n    rotating: _rotating2.default,\n    rows: _rows2.default,\n    state: _state2.default,\n    swapping: _swapping2.default,\n    value: _value2.default\n};\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n\n\n    function adjacentCellsAt(position) {\n        var adjacence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _index.adjacences.ALL;\n        var includeOutsideValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var gridSize = !includeOutsideValues && [columns, rows];\n        var grid = (0, _utils.unflatten)(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCells() {\n        var adjacence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _index.adjacences.ALL;\n        var includeOutsideValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var gridSize = !includeOutsideValues && [columns, rows];\n        var grid = (0, _utils.unflatten)(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        adjacentCells: adjacentCells,\n        adjacentCellsAt: adjacentCellsAt\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _adjacentCells(grid, position, adjacence) {\n    var gridSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    return adjacence.reduce(function (res, direction) {\n        var absPos = (0, _utils.addPositions)(position, direction);\n        var value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return (0, _utils.isNotInArea)(gridSize, absPos) ? res : [].concat(_toConsumableArray(res), [value]);\n        } else {\n            return [].concat(_toConsumableArray(res), [value]);\n        }\n    }, []);\n}\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports._getAreaAt = undefined;\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n\n\n    function areaFits(area, anchor) {\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFitsAt(position, area, anchor) {\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getArea(size, anchor) {\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getAreaAt(position, size, anchor) {\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setArea(area, anchor) {\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setAreaAt(position, area, anchor) {\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function findInArea(position, size, callback) {\n        var area = _getAreaAt(data, columns, rows, position, size);\n        var flat = (0, _utils.flatten)(area);\n        var areaIndex = flat.findIndex(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), context);\n        });\n        if (areaIndex < 0) {\n            return;\n        }\n        var areaColumns = area[0].length;\n        var posInArea = (0, _utils.index2pos)(areaIndex, areaColumns);\n        return [position[0] + posInArea[0], position[1] + posInArea[1]];\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceAreaAt(position, size, callback, initialValue) {\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceArea(size, callback, initialValue) {\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    return {\n        areaFits: areaFits,\n        areaFitsAt: areaFitsAt,\n        getArea: getArea,\n        getAreaAt: getAreaAt,\n        setArea: setArea,\n        setAreaAt: setAreaAt,\n        findInArea: findInArea,\n        reduceArea: reduceArea,\n        reduceAreaAt: reduceAreaAt\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _getAreaAt = exports._getAreaAt = function _getAreaAt(data, columns, rows, position, size) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var posTmp = (0, _utils.subtractPositions)(position, anchor);\n    var end = [Math.min(posTmp[0] + size[0], columns), Math.min(posTmp[1] + size[1], rows)];\n    var pos = [Math.max(0, posTmp[0]), Math.max(0, posTmp[1])];\n    var area = [];\n    for (var r = pos[1]; r < end[1]; r++) {\n        var rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (var c = pos[0]; c < end[0]; c++) {\n            var cArea = c - pos[0];\n            area[rArea][cArea] = (0, _utils.getValueAt)(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nvar _checkAreaFitsAt = function _checkAreaFitsAt(columns, rows, position, area) {\n    var anchor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n\n    var pos = (0, _utils.subtractPositions)(position, anchor);\n    var fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    var fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n};\n\nvar _setAreaAt = function _setAreaAt(data, columns, rows, position, area) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var pos = (0, _utils.subtractPositions)(position, anchor);\n    area.forEach(function (row, r) {\n        var targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach(function (cell, c) {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            (0, _utils.setValueAt)(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nfunction _reduceAreaAt(api, data, columns, rows, position, size, callback, initialValue, hasInitialValue) {\n    if (!(0, _utils.isValidPositionFormat)(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!(0, _utils.isValidPositionFormat)(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    var reducer = function reducer(acc, v, i) {\n        var local = (0, _utils.index2pos)(i, size[0]);\n        var global = (0, _utils.addPositions)(local, position);\n        return callback(acc, v, global, api);\n    };\n    var flattenedArea = (0, _utils.flatten)(_getAreaAt(data, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports._clip = undefined;\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n\n\n    function clip(size) {\n        var grid = _clip(data, columns, rows, position, size);\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            rows: grid.length,\n            columns: grid[0].length\n        });\n        return context;\n    }\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        var grid = _clip(data, columns, rows, position, size);\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            rows: grid.length,\n            columns: grid[0].length\n        });\n        return context;\n    }\n\n    return { clip: clip, clipAt: clipAt };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _clip = exports._clip = function _clip(data, columns, rows, position, size) {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error('Trying to clip data at an invalid position. Given: ' + position);\n    }\n    var endPoint = (0, _utils.addPositions)(position, size);\n    return (0, _utils.unflatten)(data, columns).filter(function (row, r) {\n        return r >= position[1] && r < endPoint[1];\n    }).map(function (row) {\n        return row.filter(function (cell, c) {\n            return c >= position[0] && c < endPoint[0];\n        });\n    });\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows;\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n\n\n    function numColumns() {\n        return columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        return (0, _utils.getColumn)((0, _utils.unflatten)(data, columns), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        if (x < 0 || x > columns) {\n            throw new Error('Trying to add column at an invalid position. Given: ' + x);\n        }\n        if (column.length !== rows) {\n            throw new Error('Trying to add a column that contains an invalid amount of cells. Expected: ' + rows + ', Given: ' + column.length);\n        }\n        var grid = _utils2.default.unflatten(data, columns).map(function (row, i) {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n\n        stateProvider.setState({\n            data: _utils2.default.flatten(grid),\n            columns: grid[0].length\n        });\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        if (x < 0 || x >= columns) {\n            throw new Error('Trying to remove a column at an invalid position. Given: ' + x);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns).map(function (row) {\n            return row.filter(function (v, c) {\n                return c !== x;\n            });\n        });\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            columns: grid[0].length\n        });\n        return context;\n    }\n\n    return {\n        addColumn: addColumn,\n        column: column,\n        numColumns: numColumns,\n        removeColumn: removeColumn\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns;\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n\n\n    function find(callback) {\n        var index = data.findIndex(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), context);\n        });\n        return index >= 0 ? (0, _utils.index2pos)(index, columns) : undefined;\n    }\n\n    return { find: find };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns;\n\n    var grid = (0, _utils.unflatten)(data, columns);\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    var flipX = function flipX(xPos) {\n        stateProvider.setState({ data: (0, _utils.flatten)(_flip(grid, xPos)) });\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        stateProvider.setState({ data: (0, _utils.flatten)(grid.map(function (row) {\n                return _flip(row, yPos);\n            })) });\n        return context;\n    }\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @deprecated Will be removed in version > 0.9.x. Use [flipX()]{@link gridl#flipX}  instead.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    var mirrorX = flipX;\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @deprecated Will be removed in version > 0.9.x. Use [flipY()]{@link gridl#flipY}  instead.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    var mirrorY = flipY;\n\n    return { flipX: flipX, flipY: flipY, mirrorX: mirrorX, mirrorY: mirrorY };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _flip(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    var limitedIdx = (0, _utils.limit)(index, 0, arr.length - 1);\n    var left = arr.filter(function (v, i) {\n        return i < limitedIdx;\n    });\n    var right = arr.filter(function (v, i) {\n        return i > limitedIdx;\n    });\n    return [].concat(_toConsumableArray(right.reverse()), [arr[limitedIdx]], _toConsumableArray(left.reverse()));\n}\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (context, stateProvider) {\n  var _stateProvider$getSta = stateProvider.getState(),\n      data = _stateProvider$getSta.data,\n      columns = _stateProvider$getSta.columns,\n      rows = _stateProvider$getSta.rows,\n      position = _stateProvider$getSta.position;\n\n  /**\n   * Map over all cells. It's the equivalent of Array.map just for the grid.\n   *\n   * @memberOf gridl\n   * @method\n   * @instance\n   *\n   * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n   * @returns {gridl} A new gridl instance.\n   */\n\n\n  function map(callback) {\n    var newData = data.map(function (v, i) {\n      return callback(v, (0, _utils.index2pos)(i, columns), context);\n    });\n    return (0, _index2.default)((0, _utils.unflatten)(newData, columns));\n  }\n\n  /**\n   * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n   *\n   * @memberOf gridl\n   * @method\n   * @instance\n   *\n   * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n   * @returns {gridl} The same gridl instance.\n   */\n  function forEach(callback) {\n    data.forEach(function (v, i) {\n      return callback(v, (0, _utils.index2pos)(i, columns), context);\n    });\n    return context;\n  }\n\n  /**\n   * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n   *\n   * @memberOf gridl\n   * @method\n   * @instance\n   *\n   * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n   * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n   * @returns {*} The value that results from the reduction.\n   */\n  function reduce(callback, initialValue) {\n    var reducer = function reducer(acc, v, i) {\n      return callback(acc, v, (0, _utils.index2pos)(i, columns), context);\n    };\n    return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n  }\n\n  return {\n    map: map,\n    forEach: forEach,\n    reduce: reduce\n  };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default']; /**\n                                      * @callback iteratorCallback\n                                      * @param {*} cell - The value of the current cell.\n                                      * @param {Array.<number>} position - The current position.\n                                      * @param {gridl} gridlInstance - The current gridl instance.\n                                      */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n\n\n    function moveAbs(to) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, position, to)\n        });\n        return context;\n    }\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, from, to)\n        });\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error('Trying to move column from an invalid position. Given: ' + xFrom);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error('Trying to move column to an invalid position. Given: ' + xTo);\n        }\n        stateProvider.setState({\n            data: (0, _utils.flatten)((0, _utils.unflatten)(data, columns).map(function (row) {\n                return _move(row, xFrom, xTo);\n            }))\n        });\n        return context;\n    }\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRel(direction) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, position, (0, _utils.addPositions)(position, direction))\n        });\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error('Trying to move row from an invalid position. Given: ' + yFrom);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error('Trying to move row to an invalid position. Given: ' + yTo);\n        }\n        stateProvider.setState({\n            data: (0, _utils.flatten)(_move((0, _utils.unflatten)(data, columns), yFrom, yTo))\n        });\n        return context;\n    }\n\n    return {\n        moveAbs: moveAbs,\n        moveCell: moveCell,\n        moveColumn: moveColumn,\n        moveRel: moveRel,\n        moveRow: moveRow\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _move = function _move(data, fromIndex, toIndex) {\n    var cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nvar _moveCell = function _moveCell(data, columns, rows, from, to) {\n    var fromIndex = (0, _utils.pos2index)(from, columns);\n    var size = [columns, rows];\n    if (isNaN(fromIndex) || (0, _utils.isNotInArea)(size, from)) {\n        throw new Error('Trying to move cell from an invalid position. Given: [' + from + ']');\n    }\n    var toIndex = (0, _utils.pos2index)(to, columns);\n    if (isNaN(toIndex) || (0, _utils.isNotInArea)(size, to)) {\n        throw new Error('Trying to move cell to an invalid position. Given: [' + to + ']');\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n\n    var state = stateProvider.getState();\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    function position() {\n        return [state.position[0], state.position[1]];\n    }\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    function goto(position) {\n        if (!(0, _utils.isValidPositionFormat)(position)) {\n            throw new Error('Trying to go to an invalid position. Given: ' + position);\n        }\n        stateProvider.setState({\n            position: [position[0], position[1]]\n        });\n        return context;\n    }\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    function walk(direction) {\n        if (!(0, _utils.isValidPositionFormat)(direction)) {\n            throw new Error('Trying to walk into an invalid direction. Given: ' + direction);\n        }\n        var targetPos = (0, _utils.addPositions)(state.position, direction);\n        stateProvider.setState({ position: targetPos });\n        return context;\n    }\n\n    return {\n        goto: goto,\n        position: position,\n        walk: walk\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns;\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n\n\n    function rotate(steps) {\n        var grid = _rotate((0, _utils.unflatten)(data, columns), columns, steps);\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            rows: grid.length,\n            columns: grid[0].length\n        });\n        return context;\n    }\n\n    return { rotate: rotate };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _rotate(grid, columns, steps) {\n    var mod = steps % 4;\n    var option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, i).reverse();\n            });\n        case 2:\n            return grid.reverse().map(function (row, r) {\n                return row.reverse();\n            });\n        case 3:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, columns - 1 - i);\n            });\n        default:\n            throw new Error('Trying to rotate the grid with an invalid steps parameter. Given: ' + steps);\n    }\n}\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        rows = _stateProvider$getSta.rows,\n        columns = _stateProvider$getSta.columns;\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n\n\n    function numRows() {\n        return rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        return getRow((0, _utils.unflatten)(data, columns), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        if (y < 0 || y > rows) {\n            throw new Error('Trying to add row at an invalid position. Given: ' + y);\n        }\n        if (row.length !== columns) {\n            throw new Error('Trying to add a row that contains an invalid amount of cells. Expected: ' + columns + ', Given: ' + row.length);\n        }\n        var grid = (0, _utils.unflatten)(data, columns);\n        grid.splice(y, 0, row);\n\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            rows: grid.length\n        });\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        if (y < 0 || y >= rows) {\n            throw new Error('Trying to remove a row at an invalid position. Given: ' + y);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns);\n        grid.splice(y, 1);\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid),\n            rows: grid.length\n        });\n        return context;\n    }\n\n    return {\n        addRow: addRow,\n        numRows: numRows,\n        removeRow: removeRow,\n        row: row\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getRow = function getRow(data, y) {\n    return data[y];\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n\n    var state = stateProvider.getState();\n    var columns = state.columns,\n        rows = state.rows,\n        position = state.position;\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n\n    function size() {\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array.\n     */\n    function data() {\n        return (0, _utils.unflatten)(state.data, columns);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return [].concat(_toConsumableArray(state.data));\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        return (0, _index2.default)((0, _utils.unflatten)(state.data, columns)).goto(position);\n    }\n\n    return {\n        size: size,\n        data: data,\n        list: list,\n        clone: clone\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} otherPosition - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n\n\n    function swapCell(otherPosition) {\n        _swapCells(data, columns, rows, position, otherPosition);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error('Trying to swap columns from an invalid position. Given: ' + x1);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error('Trying to swap columns to an invalid position. Given: ' + x2);\n        }\n        var grid = (0, _utils.unflatten)(data, columns).map(function (row) {\n            _swap(row, x1, x2);\n            return row;\n        });\n        stateProvider.setState({\n            data: (0, _utils.flatten)(grid)\n        });\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error('Trying to swap rows from an invalid position. Given: ' + y1);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error('Trying to swap rows to an invalid position. Given: ' + y2);\n        }\n        stateProvider.setState({\n            data: (0, _utils.flatten)(_swap((0, _utils.unflatten)(data, columns), y1, y2))\n        });\n        return context;\n    }\n\n    return {\n        swapCell: swapCell,\n        swapCells: swapCells,\n        swapColumns: swapColumns,\n        swapRows: swapRows\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _swap = function _swap(arr, i1, i2) {\n    var tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nvar _swapCells = function _swapCells(data, columns, rows, position1, position2) {\n    var size = [columns, rows];\n    if ((0, _utils.isNotInArea)(size, position1) || (0, _utils.isNotInArea)(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    var index1 = (0, _utils.pos2index)(position1, columns);\n    var index2 = (0, _utils.pos2index)(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, stateProvider) {\n    var _stateProvider$getSta = stateProvider.getState(),\n        data = _stateProvider$getSta.data,\n        columns = _stateProvider$getSta.columns,\n        rows = _stateProvider$getSta.rows,\n        position = _stateProvider$getSta.position;\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n\n\n    function value(value) {\n        if (arguments.length < 1) {\n            return (0, _utils.getValueAt)(data, columns, position);\n        }\n        (0, _utils.setValueAt)(data, columns, rows, position, value);\n        return context;\n    }\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        if (arguments.length < 2) {\n            return (0, _utils.getValueAt)(data, columns, pos);\n        }\n        (0, _utils.setValueAt)(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { value: value, valueAt: valueAt };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nvar adjacences = Object.freeze({\n    ALL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT]),\n    ALL_CW: Object.freeze([_directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN, _directions2.default.DOWN_LEFT, _directions2.default.LEFT, _directions2.default.UP_LEFT]),\n    ALL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.UP_LEFT, _directions2.default.LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT, _directions2.default.RIGHT, _directions2.default.UP_RIGHT]),\n    ORTHOGONAL: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN]),\n    ORTHOGONAL_CW: Object.freeze([_directions2.default.UP, _directions2.default.RIGHT, _directions2.default.DOWN, _directions2.default.LEFT]),\n    ORTHOGONAL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.DOWN, _directions2.default.RIGHT]),\n    DIAGONAL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT]),\n    DIAGONAL_CW: Object.freeze([_directions2.default.UP_RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.UP_LEFT]),\n    DIAGONAL_CCW: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT, _directions2.default.UP_RIGHT])\n});\n\nexports.default = adjacences;\nmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// gridl.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5a4d5fc43e8eb1e23d8d","/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nexport const index2pos = (index, columns) => [index % columns, Math.floor(index / columns)];\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nexport const pos2index = (position, columns) => position && position[0] + position[1] * columns;\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nexport const flatten = array2D => array2D.reduce((res, row) => [...res, ...row], []);\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nexport const unflatten = (array1D, columns) => array1D.reduce((res, cell, index) => {\n    const pos = index2pos(index, columns);\n    if (!res[pos[1]]) {\n        res[pos[1]] = [];\n    }\n    res[pos[1]][pos[0]] = cell;\n    return res;\n}, []);\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nexport const addPositions = (p1, p2) => [\n    p1[0] + p2[0],\n    p1[1] + p2[1],\n];\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nexport const subtractPositions = (p1, p2) => [\n    p1[0] - p2[0],\n    p1[1] - p2[1],\n];\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nexport const limit = (value, min, max) => Math.max(Math.min(value, max), min);\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nexport const isNotInArea = (areaSize, position) => (\n    position[0] < 0 || position[0] >= areaSize[0] ||\n    position[1] < 0 || position[1] >= areaSize[1]\n);\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nexport const getValueAt = (data, columns, pos) => {\n    const index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nexport const setValueAt = (data, columns, rows, pos, value) => {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    const index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nexport const getColumn = (data, x) => {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(row => row[x]);\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nexport const isValidPositionFormat = position => {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return (Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]));\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nexport const validateGridArray = data => {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach((row, i) => {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with different row lengths.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nconst utils = {\n    flatten,\n    isValidPositionFormat,\n    unflatten,\n    index2pos,\n    pos2index,\n    addPositions,\n    subtractPositions,\n    limit,\n    isNotInArea,\n    getColumn,\n    getValueAt,\n    setValueAt,\n    validateGridArray,\n};\n\nexport default utils;\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import utils from './utils';\nimport generators from './generators';\nimport plugins from './plugins';\nimport directions from './directions';\nimport adjacences from './adjacences';\n\nconst { flatten, validateGridArray } = utils;\n\n/**\n * @class\n * @private\n */\nfunction gridl(fn, data) {\n\n    // validate incoming data\n    validateGridArray(data);\n\n    const _state = {};\n\n    const _stateProvider = {\n        getState: () => _state,\n        setState: (newState) => {\n            // set state\n            Object.entries(newState).forEach(([key, value]) => _state[key] = value);\n\n            // update plugins\n            Object.entries(fn).forEach(([key, pluginFactory]) => {\n                const plugin = pluginFactory(this, _stateProvider);\n                const type = typeof plugin;\n\n                // plugin is just a function\n                if (type === 'function') {\n                    this[key] = plugin;\n                }\n\n                // plugin returns multiple functions bundled together in an object\n                else if (type === 'object') {\n                    Object.entries(plugin).forEach(([k, func]) => {\n                        this[k] = func;\n                    });\n                }\n            });\n        },\n    };\n\n    // set initial state\n    _stateProvider.setState({\n        rows: data.length,\n        columns: data[0].length,\n        data: flatten(data),\n        position: [0,0],\n    });\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n */\nconst gridlFactory = data => new gridl(gridlFactory.fn, data);\ngridlFactory.fn = plugins;\n\nexport { utils, generators, adjacences, directions};\n\nexport default gridlFactory;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nconst directions = Object.freeze({\n    UP:         Object.freeze([ 0, -1]),\n    UP_RIGHT:   Object.freeze([ 1, -1]),\n    RIGHT:      Object.freeze([ 1,  0]),\n    DOWN_RIGHT: Object.freeze([ 1,  1]),\n    DOWN:       Object.freeze([ 0,  1]),\n    DOWN_LEFT:  Object.freeze([-1,  1]),\n    LEFT:       Object.freeze([-1,  0]),\n    UP_LEFT:    Object.freeze([-1, -1]),\n});\n\nexport default directions;\n\n\n\n// WEBPACK FOOTER //\n// ./src/directions.js","import gridl from './index';\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nexport function makeDataGrid(columns, rows, callback = () => null) {\n    const parsedColumns = parseInt(columns);\n    const parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error(`You need to specify at least one column. Given: ${columns}`);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error(`You need to specify at least one row. Given: ${rows}`);\n    }\n    return Array.from({ length: parsedRows }, (vr, row) => (\n        Array.from({ length: parsedColumns }, (vc, column) => (\n            callback({ column, row })\n        ))\n    ));\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nexport function makeDataList(length, callback = () => null) {\n    const parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error(`Trying to make a list with an invalid length. Given: ${length}`);\n    }\n    return Array.from({ length: parsedLength }, (v, i) => callback(i));\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nexport function makeGridl(numColumns, numRows, callback) {\n    return gridl(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexport default {\n    makeGridl,\n    makeDataGrid,\n    makeDataList,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/generators.js","import adjacence from './adjacence';\nimport area from './area';\nimport clipping from './clipping';\nimport columns from './columns';\nimport finding from './finding';\nimport flipping from './flipping';\nimport iterator from './iterator';\nimport moving from './moving';\nimport navigating from './navigating';\nimport rotating from './rotating';\nimport rows from './rows';\nimport state from './state';\nimport swapping from './swapping';\nimport value from './value';\n\nexport default {\n    adjacence,\n    area,\n    clipping,\n    columns,\n    finding,\n    flipping,\n    iterator,\n    moving,\n    navigating,\n    rotating,\n    rows,\n    state,\n    swapping,\n    value,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/index.js","import gridl, {adjacences} from '../index';\nimport { unflatten, addPositions, isNotInArea } from '../utils';\n\nfunction _adjacentCells(grid, position, adjacence, gridSize = null) {\n    return adjacence.reduce((res, direction) => {\n        const absPos = addPositions(position, direction);\n        const value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return isNotInArea(gridSize, absPos) ? res : [...res, value];\n        }\n        else {\n            return [...res, value];\n        }\n    }, []);\n}\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCellsAt(position, adjacence = adjacences.ALL, includeOutsideValues = false) {\n        const gridSize = !includeOutsideValues && [columns, rows];\n        const grid = unflatten(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCells(adjacence = adjacences.ALL, includeOutsideValues = false) {\n        const gridSize = !includeOutsideValues && [columns, rows];\n        const grid = unflatten(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        adjacentCells,\n        adjacentCellsAt,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/adjacence.js","import gridl from '../index';\nimport {\n    setValueAt,\n    subtractPositions,\n    index2pos,\n    flatten,\n    addPositions,\n    isValidPositionFormat, getValueAt,\n} from '../utils';\n\nexport const _getAreaAt = (data, columns, rows, position, size, anchor = [0,0]) => {\n    const posTmp = subtractPositions(position, anchor);\n    const end = [\n        Math.min(posTmp[0] + size[0], columns),\n        Math.min(posTmp[1] + size[1], rows),\n    ];\n    const pos = [\n        Math.max(0, posTmp[0]),\n        Math.max(0, posTmp[1]),\n    ];\n    const area = [];\n    for (let r = pos[1]; r < end[1]; r++) {\n        const rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (let c = pos[0]; c < end[0]; c++) {\n            const cArea = c - pos[0];\n            area[rArea][cArea] = getValueAt(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nconst _checkAreaFitsAt = (columns, rows, position, area, anchor = [0,0]) => {\n    const pos = subtractPositions(position, anchor);\n    const fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    const fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n};\n\nconst _setAreaAt = (data, columns, rows, position, area, anchor = [0,0]) => {\n    const pos = subtractPositions(position, anchor);\n    area.forEach((row, r) => {\n        const targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach((cell, c) => {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            setValueAt(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nfunction _reduceAreaAt(api, data, columns, rows, position, size, callback, initialValue, hasInitialValue) {\n    if (!isValidPositionFormat(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!isValidPositionFormat(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    const reducer = (acc, v, i) => {\n        const local = index2pos(i, size[0]);\n        const global = addPositions(local, position);\n        return callback(acc, v, global, api);\n    };\n    const flattenedArea = flatten(_getAreaAt(data, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n}\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFits(area, anchor) {\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFitsAt(position, area, anchor) {\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getArea(size, anchor) {\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getAreaAt(position, size, anchor) {\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setArea(area, anchor) {\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setAreaAt(position, area, anchor) {\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function findInArea(position, size, callback) {\n        const area = _getAreaAt(data, columns, rows, position, size);\n        const flat = flatten(area);\n        const areaIndex = flat.findIndex((v, i) => callback(v, index2pos(i, columns), context));\n        if (areaIndex < 0) {\n            return;\n        }\n        const areaColumns = area[0].length;\n        const posInArea = index2pos(areaIndex, areaColumns);\n        return [\n            position[0] + posInArea[0],\n            position[1] + posInArea[1],\n        ];\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceAreaAt(position, size, callback, initialValue) {\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceArea(size, callback, initialValue) {\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    return {\n        areaFits,\n        areaFitsAt,\n        getArea,\n        getAreaAt,\n        setArea,\n        setAreaAt,\n        findInArea,\n        reduceArea,\n        reduceAreaAt,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/area.js","import { addPositions, flatten, unflatten } from '../utils';\n\nexport const _clip = (data, columns, rows, position, size) => {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error(`Trying to clip data at an invalid position. Given: ${position}`);\n    }\n    const endPoint = addPositions(position, size);\n    return unflatten(data, columns)\n        .filter((row, r) => r >= position[1] && r < endPoint[1])\n        .map(row => row.filter((cell, c) => c >= position[0] && c < endPoint[0]));\n};\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clip(size) {\n        const grid = _clip(data, columns, rows, position, size);\n        stateProvider.setState({\n            data: flatten(grid),\n            rows: grid.length,\n            columns: grid[0].length,\n        });\n        return context;\n    }\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        const grid = _clip(data, columns, rows, position, size);\n        stateProvider.setState({\n            data: flatten(grid),\n            rows: grid.length,\n            columns: grid[0].length,\n        });\n        return context;\n    }\n\n    return { clip, clipAt };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/clipping.js","import gridl from '../index';\nimport { flatten, unflatten, getColumn } from '../utils';\nimport utils from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows } = stateProvider.getState();\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numColumns() {\n        return columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        return getColumn(unflatten(data, columns), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        if (x < 0 || x > columns) {\n            throw new Error(`Trying to add column at an invalid position. Given: ${x}`);\n        }\n        if (column.length !== rows) {\n            throw new Error(`Trying to add a column that contains an invalid amount of cells. Expected: ${rows}, Given: ${column.length}`);\n        }\n        const grid = utils.unflatten(data, columns).map((row, i) => {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n\n        stateProvider.setState({\n            data: utils.flatten(grid),\n            columns: grid[0].length,\n        });\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        if (x < 0 || x >= columns) {\n            throw new Error(`Trying to remove a column at an invalid position. Given: ${x}`);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns).map(row => row.filter((v, c) => c !== x));\n        stateProvider.setState({\n            data: flatten(grid),\n            columns: grid[0].length,\n        });\n        return context;\n    }\n\n    return {\n        addColumn,\n        column,\n        numColumns,\n        removeColumn,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/columns.js","import { index2pos } from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const { data, columns } = stateProvider.getState();\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function find(callback) {\n        const index = data.findIndex((v, i) => callback(v, index2pos(i, columns), context));\n        return (index >= 0) ? index2pos(index, columns) : undefined;\n    }\n\n    return { find };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/finding.js","import { unflatten, flatten, limit } from '../utils';\n\nfunction _flip(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    const limitedIdx = limit(index, 0, arr.length - 1);\n    const left = arr.filter((v, i) => i < limitedIdx);\n    const right = arr.filter((v, i) => i > limitedIdx);\n    return [\n        ...right.reverse(),\n        arr[limitedIdx],\n        ...left.reverse(),\n    ];\n}\n\nexport default function(context, stateProvider) {\n\n    const { data, columns } = stateProvider.getState();\n    const grid = unflatten(data, columns);\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    const flipX = (xPos) => {\n        stateProvider.setState({ data: flatten(_flip(grid, xPos)) });\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        stateProvider.setState({ data: flatten(grid.map(row => _flip(row, yPos))) });\n        return context;\n    }\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @deprecated Will be removed in version > 0.9.x. Use [flipX()]{@link gridl#flipX}  instead.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    const mirrorX = flipX;\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @deprecated Will be removed in version > 0.9.x. Use [flipY()]{@link gridl#flipY}  instead.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    const mirrorY = flipY;\n\n    return { flipX, flipY, mirrorX, mirrorY };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/flipping.js","/**\n * @callback iteratorCallback\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\nimport gridl from '../index';\nimport { index2pos, unflatten } from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    function map(callback) {\n        const newData = data.map((v, i) => callback(v, index2pos(i, columns), context));\n        return gridl(unflatten(newData, columns));\n    }\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    function forEach(callback) {\n        data.forEach((v, i) => callback(v, index2pos(i, columns), context));\n        return context;\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduce(callback, initialValue) {\n        const reducer = (acc, v, i) => callback(acc, v, index2pos(i, columns), context);\n        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n    }\n\n    return {\n        map,\n        forEach,\n        reduce,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/iterator.js","import {\n    addPositions,\n    flatten,\n    isNotInArea,\n    pos2index,\n    unflatten,\n} from '../utils';\n\nconst _move = (data, fromIndex, toIndex) => {\n    const cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nconst _moveCell = (data, columns, rows, from, to) => {\n    const fromIndex = pos2index(from, columns);\n    const size = [columns, rows];\n    if (isNaN(fromIndex) || isNotInArea(size, from)) {\n        throw new Error(`Trying to move cell from an invalid position. Given: [${from}]`);\n    }\n    const toIndex = pos2index(to, columns);\n    if (isNaN(toIndex) || isNotInArea(size, to)) {\n        throw new Error(`Trying to move cell to an invalid position. Given: [${to}]`);\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n    function moveAbs(to) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, position, to),\n        });\n        return context;\n    }\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, from, to),\n        });\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error(`Trying to move column from an invalid position. Given: ${xFrom}`);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error(`Trying to move column to an invalid position. Given: ${xTo}`);\n        }\n        stateProvider.setState({\n            data: flatten(unflatten(data, columns).map(row => _move(row, xFrom, xTo))),\n        });\n        return context;\n    }\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRel(direction) {\n        stateProvider.setState({\n            data: _moveCell(data, columns, rows, position, addPositions(position, direction)),\n        });\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error(`Trying to move row from an invalid position. Given: ${yFrom}`);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error(`Trying to move row to an invalid position. Given: ${yTo}`);\n        }\n        stateProvider.setState({\n            data: flatten(_move(unflatten(data, columns), yFrom, yTo)),\n        });\n        return context;\n    }\n\n    return {\n        moveAbs,\n        moveCell,\n        moveColumn,\n        moveRel,\n        moveRow,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/moving.js","import gridl from '../index';\nimport { addPositions, isValidPositionFormat } from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const state = stateProvider.getState();\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    function position() {\n        return [\n            state.position[0],\n            state.position[1],\n        ];\n    }\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    function goto(position) {\n        if (!isValidPositionFormat(position)) {\n            throw new Error(`Trying to go to an invalid position. Given: ${position}`);\n        }\n        stateProvider.setState({\n            position: [\n                position[0],\n                position[1],\n            ],\n        });\n        return context;\n    }\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    function walk(direction) {\n        if (!isValidPositionFormat(direction)) {\n            throw new Error(`Trying to walk into an invalid direction. Given: ${direction}`);\n        }\n        const targetPos = addPositions(state.position, direction);\n        stateProvider.setState({ position: targetPos });\n        return context;\n    }\n\n    return {\n        goto,\n        position,\n        walk,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/navigating.js","import { getColumn, unflatten, flatten } from '../utils';\n\nfunction _rotate(grid, columns, steps) {\n    const mod = steps % 4;\n    const option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, i).reverse());\n        case 2:\n            return grid.reverse().map((row, r) => row.reverse());\n        case 3:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, columns - 1 - i));\n        default:\n            throw new Error(`Trying to rotate the grid with an invalid steps parameter. Given: ${steps}`);\n    }\n}\n\nexport default function(context, stateProvider) {\n\n    const { data, columns } = stateProvider.getState();\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    function rotate(steps) {\n        const grid = _rotate(unflatten(data, columns), columns, steps);\n        stateProvider.setState({\n            data: flatten(grid),\n            rows: grid.length,\n            columns: grid[0].length,\n        });\n        return context;\n    }\n\n    return { rotate };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rotating.js","import gridl from '../index';\nimport { flatten, unflatten } from '../utils';\n\nconst getRow = (data, y) => data[y];\n\nexport default function(context, stateProvider) {\n\n    const { data, rows, columns} = stateProvider.getState();\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numRows() {\n        return rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        return getRow(unflatten(data, columns), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        if (y < 0 || y > rows) {\n            throw new Error(`Trying to add row at an invalid position. Given: ${y}`);\n        }\n        if (row.length !== columns) {\n            throw new Error(`Trying to add a row that contains an invalid amount of cells. Expected: ${columns}, Given: ${row.length}`);\n        }\n        const grid = unflatten(data, columns);\n        grid.splice(y, 0, row);\n\n        stateProvider.setState({\n            data: flatten(grid),\n            rows: grid.length,\n        });\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        if (y < 0 || y >= rows) {\n            throw new Error(`Trying to remove a row at an invalid position. Given: ${y}`);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns);\n        grid.splice(y, 1);\n        stateProvider.setState({\n            data: flatten(grid),\n            rows: grid.length,\n        });\n        return context;\n    }\n\n    return {\n        addRow,\n        numRows,\n        removeRow,\n        row,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rows.js","import gridl from '../index';\nimport { unflatten } from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const state = stateProvider.getState();\n    const { columns, rows, position } = state;\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n    function size() {\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array.\n     */\n    function data() {\n        return unflatten(state.data, columns);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return ([...state.data]);\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        return gridl(unflatten(state.data, columns)).goto(position);\n    }\n\n    return {\n        size,\n        data,\n        list,\n        clone,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/state.js","import { flatten, isNotInArea, pos2index, unflatten } from '../utils';\n\nconst _swap = (arr, i1, i2) => {\n    const tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nconst _swapCells = (data, columns, rows, position1, position2) => {\n    const size = [columns, rows];\n    if (isNotInArea(size, position1) || isNotInArea(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    const index1 = pos2index(position1, columns);\n    const index2 = pos2index(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} otherPosition - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCell(otherPosition) {\n        _swapCells(data, columns, rows, position, otherPosition);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error(`Trying to swap columns from an invalid position. Given: ${x1}`);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error(`Trying to swap columns to an invalid position. Given: ${x2}`);\n        }\n        const grid = unflatten(data, columns).map(row => {\n            _swap(row, x1, x2);\n            return row;\n        });\n        stateProvider.setState({\n            data: flatten(grid),\n        });\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error(`Trying to swap rows from an invalid position. Given: ${y1}`);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error(`Trying to swap rows to an invalid position. Given: ${y2}`);\n        }\n        stateProvider.setState({\n            data: flatten(_swap(unflatten(data, columns), y1, y2)),\n        });\n        return context;\n    }\n\n    return {\n        swapCell,\n        swapCells,\n        swapColumns,\n        swapRows,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/swapping.js","import { getValueAt, setValueAt } from '../utils';\n\nexport default function(context, stateProvider) {\n\n    const { data, columns, rows, position } = stateProvider.getState();\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n    function value(value) {\n        if (arguments.length < 1) {\n            return getValueAt(data, columns, position);\n        }\n        setValueAt(data, columns, rows, position, value);\n        return context;\n    }\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        if (arguments.length < 2) {\n            return getValueAt(data, columns, pos);\n        }\n        setValueAt(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { value, valueAt };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/value.js","import directions from './directions';\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nconst adjacences = Object.freeze({\n    ALL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n    ]),\n    ALL_CW: Object.freeze([\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN,\n        directions.DOWN_LEFT,\n        directions.LEFT,\n        directions.UP_LEFT,\n    ]),\n    ALL_CCW: Object.freeze([\n        directions.UP,\n        directions.UP_LEFT,\n        directions.LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n        directions.RIGHT,\n        directions.UP_RIGHT,\n    ]),\n    ORTHOGONAL: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN,\n    ]),\n    ORTHOGONAL_CW: Object.freeze([\n        directions.UP,\n        directions.RIGHT,\n        directions.DOWN,\n        directions.LEFT,\n    ]),\n    ORTHOGONAL_CCW: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.DOWN,\n        directions.RIGHT,\n    ]),\n    DIAGONAL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP_RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n    ]),\n    DIAGONAL_CW: Object.freeze([\n        directions.UP_RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN_LEFT,\n        directions.UP_LEFT,\n    ]),\n    DIAGONAL_CCW: Object.freeze([\n        directions.UP_LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n        directions.UP_RIGHT,\n    ]),\n});\n\nexport default adjacences;\n\n\n// WEBPACK FOOTER //\n// ./src/adjacences.js"],"sourceRoot":""}